{"version":3,"file":"speech-commands.js","sources":["../src/browser_fft_utils.ts","../src/browser_fft_extractor.ts","../src/generic_utils.ts","../src/training_utils.ts","../src/dataset.ts","../src/version.ts","../src/browser_fft_recognizer.ts","../src/index.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs';\nimport {promisify} from 'util';\n\nimport {RawAudioData} from './types';\n\nexport async function loadMetadataJson(url: string):\n    Promise<{wordLabels: string[]}> {\n  const HTTP_SCHEME = 'http://';\n  const HTTPS_SCHEME = 'https://';\n  const FILE_SCHEME = 'file://';\n  if (url.indexOf(HTTP_SCHEME) === 0 || url.indexOf(HTTPS_SCHEME) === 0) {\n    const response = await fetch(url);\n    const parsed = await response.json();\n    return parsed;\n  } else if (url.indexOf(FILE_SCHEME) === 0) {\n    // tslint:disable-next-line:no-require-imports\n    const fs = require('fs');\n    const readFile = promisify(fs.readFile);\n\n    return JSON.parse(\n        await readFile(url.slice(FILE_SCHEME.length), {encoding: 'utf-8'}));\n  } else {\n    throw new Error(\n        `Unsupported URL scheme in metadata URL: ${url}. ` +\n        `Supported schemes are: http://, https://, and ` +\n        `(node.js-only) file://`);\n  }\n}\n\nlet EPSILON: number = null;\n\n/**\n * Normalize the input into zero mean and unit standard deviation.\n *\n * This function is safe against divison-by-zero: In case the standard\n * deviation is zero, the output will be all-zero.\n *\n * @param x Input tensor.\n * @param y Output normalized tensor.\n */\nexport function normalize(x: tf.Tensor): tf.Tensor {\n  if (EPSILON == null) {\n    EPSILON = tf.backend().epsilon();\n  }\n  return tf.tidy(() => {\n    const {mean, variance} = tf.moments(x);\n    // Add an EPSILON to the denominator to prevent division-by-zero.\n    return x.sub(mean).div(variance.sqrt().add(EPSILON));\n  });\n}\n\n/**\n * Z-Normalize the elements of a Float32Array.\n *\n * Subtract the mean and divide the result by the standard deviation.\n *\n * @param x The Float32Array to normalize.\n * @return Noramlzied Float32Array.\n */\nexport function normalizeFloat32Array(x: Float32Array): Float32Array {\n  if (x.length < 2) {\n    throw new Error(\n        'Cannot normalize a Float32Array with fewer than 2 elements.');\n  }\n  if (EPSILON == null) {\n    EPSILON = tf.backend().epsilon();\n  }\n  return tf.tidy(() => {\n    const {mean, variance} = tf.moments(tf.tensor1d(x));\n    const meanVal = mean.arraySync() as number;\n    const stdVal = Math.sqrt(variance.arraySync() as number);\n    const yArray = Array.from(x).map(y => (y - meanVal) / (stdVal + EPSILON));\n    return new Float32Array(yArray);\n  });\n}\n\nexport function getAudioContextConstructor(): AudioContext {\n  // tslint:disable-next-line:no-any\n  return (window as any).AudioContext || (window as any).webkitAudioContext;\n}\n\nexport async function getAudioMediaStream(\n    audioTrackConstraints?: MediaTrackConstraints): Promise<MediaStream> {\n  return navigator.mediaDevices.getUserMedia({\n    audio: audioTrackConstraints == null ? true : audioTrackConstraints,\n    video: false\n  });\n}\n\n/**\n * Play raw audio waveform\n * @param rawAudio Raw audio data, including the waveform and the sampling rate.\n * @param onEnded Callback function to execute when the playing ends.\n */\nexport function playRawAudio(\n    rawAudio: RawAudioData, onEnded: () => void|Promise<void>): void {\n  const audioContextConstructor =\n      // tslint:disable-next-line:no-any\n      (window as any).AudioContext || (window as any).webkitAudioContext;\n  const audioContext: AudioContext = new audioContextConstructor();\n  const arrayBuffer =\n      audioContext.createBuffer(1, rawAudio.data.length, rawAudio.sampleRateHz);\n  const nowBuffering = arrayBuffer.getChannelData(0);\n  nowBuffering.set(rawAudio.data);\n  const source = audioContext.createBufferSource();\n  source.buffer = arrayBuffer;\n  source.connect(audioContext.destination);\n  source.start();\n  source.onended = () => {\n    if (onEnded != null) {\n      onEnded();\n    }\n  };\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/**\n * Audio FFT Feature Extractor based on Browser-Native FFT.\n */\n\nimport * as tf from '@tensorflow/tfjs';\n\nimport {getAudioContextConstructor, getAudioMediaStream} from './browser_fft_utils';\nimport {FeatureExtractor, RecognizerParams} from './types';\n\nexport type SpectrogramCallback = (freqData: tf.Tensor, timeData?: tf.Tensor) =>\n    Promise<boolean>;\n\n/**\n * Configurations for constructing BrowserFftFeatureExtractor.\n */\nexport interface BrowserFftFeatureExtractorConfig extends RecognizerParams {\n  /**\n   * Number of audio frames (i.e., frequency columns) per spectrogram.\n   */\n  numFramesPerSpectrogram: number;\n\n  /**\n   * Suppression period in milliseconds.\n   *\n   * How much time to rest (not call the spectrogramCallback) every time\n   * a word with probability score above threshold is recognized.\n   */\n  suppressionTimeMillis: number;\n\n  /**\n   * A callback that is invoked every time a full spectrogram becomes\n   * available.\n   *\n   * `x` is a single-example tf.Tensor instance that includes the batch\n   * dimension.\n   * The return value is assumed to be whether a flag for whether the\n   * suppression period should initiate, e.g., when a word is recognized.\n   */\n  spectrogramCallback: SpectrogramCallback;\n\n  /**\n   * Truncate each spectrogram column at how many frequency points.\n   *\n   * If `null` or `undefined`, will do no truncation.\n   */\n  columnTruncateLength?: number;\n\n  /**\n   * Overlap factor. Must be >=0 and <1.\n   * For example, if the model takes a frame length of 1000 ms,\n   * and if overlap factor is 0.4, there will be a 400ms\n   * overlap between two successive frames, i.e., frames\n   * will be taken every 600 ms.\n   */\n  overlapFactor: number;\n\n  /**\n   * Whether to collect the raw time-domain audio waveform in addition to the\n   * spectrogram.\n   *\n   * Default: `false`.\n   */\n  includeRawAudio?: boolean;\n}\n\n/**\n * Audio feature extractor based on Browser-native FFT.\n *\n * Uses AudioContext and analyser node.\n */\nexport class BrowserFftFeatureExtractor implements FeatureExtractor {\n  // Number of frames (i.e., columns) per spectrogram used for classification.\n  readonly numFrames: number;\n\n  // Audio sampling rate in Hz.\n  readonly sampleRateHz: number;\n\n  // The FFT length for each spectrogram column.\n  readonly fftSize: number;\n\n  // Truncation length for spectrogram columns.\n  readonly columnTruncateLength: number;\n\n  // Overlapping factor: the ratio between the temporal spacing between\n  // consecutive spectrograms and the length of each individual spectrogram.\n  readonly overlapFactor: number;\n  readonly includeRawAudio: boolean;\n\n  private readonly spectrogramCallback: SpectrogramCallback;\n\n  private stream: MediaStream;\n  // tslint:disable-next-line:no-any\n  private audioContextConstructor: any;\n  private audioContext: AudioContext;\n  private analyser: AnalyserNode;\n  private tracker: Tracker;\n  private freqData: Float32Array;\n  private timeData: Float32Array;\n  private freqDataQueue: Float32Array[];\n  private timeDataQueue: Float32Array[];\n  // tslint:disable-next-line:no-any\n  private frameIntervalTask: any;\n  private frameDurationMillis: number;\n\n  private suppressionTimeMillis: number;\n\n  /**\n   * Constructor of BrowserFftFeatureExtractor.\n   *\n   * @param config Required configuration object.\n   */\n  constructor(config: BrowserFftFeatureExtractorConfig) {\n    if (config == null) {\n      throw new Error(\n          `Required configuration object is missing for ` +\n          `BrowserFftFeatureExtractor constructor`);\n    }\n\n    if (config.spectrogramCallback == null) {\n      throw new Error(`spectrogramCallback cannot be null or undefined`);\n    }\n\n    if (!(config.numFramesPerSpectrogram > 0)) {\n      throw new Error(\n          `Invalid value in numFramesPerSpectrogram: ` +\n          `${config.numFramesPerSpectrogram}`);\n    }\n\n    if (config.suppressionTimeMillis < 0) {\n      throw new Error(\n          `Expected suppressionTimeMillis to be >= 0, ` +\n          `but got ${config.suppressionTimeMillis}`);\n    }\n    this.suppressionTimeMillis = config.suppressionTimeMillis;\n\n    this.spectrogramCallback = config.spectrogramCallback;\n    this.numFrames = config.numFramesPerSpectrogram;\n    this.sampleRateHz = config.sampleRateHz || 44100;\n    this.fftSize = config.fftSize || 1024;\n    this.frameDurationMillis = this.fftSize / this.sampleRateHz * 1e3;\n    this.columnTruncateLength = config.columnTruncateLength || this.fftSize;\n    this.overlapFactor = config.overlapFactor;\n    this.includeRawAudio = config.includeRawAudio;\n\n    tf.util.assert(\n        this.overlapFactor >= 0 && this.overlapFactor < 1,\n        () => `Expected overlapFactor to be >= 0 and < 1, ` +\n            `but got ${this.overlapFactor}`);\n\n    if (this.columnTruncateLength > this.fftSize) {\n      throw new Error(\n          `columnTruncateLength ${this.columnTruncateLength} exceeds ` +\n          `fftSize (${this.fftSize}).`);\n    }\n\n    this.audioContextConstructor = getAudioContextConstructor();\n  }\n\n  async start(audioTrackConstraints?: MediaTrackConstraints):\n      Promise<Float32Array[]|void> {\n    if (this.frameIntervalTask != null) {\n      throw new Error(\n          'Cannot start already-started BrowserFftFeatureExtractor');\n    }\n\n    this.stream = await getAudioMediaStream(audioTrackConstraints);\n\n    this.audioContext = new this.audioContextConstructor() as AudioContext;\n    if (this.audioContext.sampleRate !== this.sampleRateHz) {\n      console.warn(\n          `Mismatch in sampling rate: ` +\n          `Expected: ${this.sampleRateHz}; ` +\n          `Actual: ${this.audioContext.sampleRate}`);\n    }\n    const streamSource = this.audioContext.createMediaStreamSource(this.stream);\n    this.analyser = this.audioContext.createAnalyser();\n    this.analyser.fftSize = this.fftSize * 2;\n    this.analyser.smoothingTimeConstant = 0.0;\n    streamSource.connect(this.analyser);\n    // Reset the queue.\n    this.freqDataQueue = [];\n    this.freqData = new Float32Array(this.fftSize);\n    if (this.includeRawAudio) {\n      this.timeDataQueue = [];\n      this.timeData = new Float32Array(this.fftSize);\n    }\n    const period =\n        Math.max(1, Math.round(this.numFrames * (1 - this.overlapFactor)));\n    this.tracker = new Tracker(\n        period,\n        Math.round(this.suppressionTimeMillis / this.frameDurationMillis));\n    this.frameIntervalTask = setInterval(\n        this.onAudioFrame.bind(this), this.fftSize / this.sampleRateHz * 1e3);\n  }\n\n  private async onAudioFrame() {\n    this.analyser.getFloatFrequencyData(this.freqData);\n    if (this.freqData[0] === -Infinity) {\n      return;\n    }\n\n    this.freqDataQueue.push(this.freqData.slice(0, this.columnTruncateLength));\n    if (this.includeRawAudio) {\n      this.analyser.getFloatTimeDomainData(this.timeData);\n      this.timeDataQueue.push(this.timeData.slice());\n    }\n    if (this.freqDataQueue.length > this.numFrames) {\n      // Drop the oldest frame (least recent).\n      this.freqDataQueue.shift();\n    }\n    const shouldFire = this.tracker.tick();\n    if (shouldFire) {\n      const freqData = flattenQueue(this.freqDataQueue);\n      const freqDataTensor = getInputTensorFromFrequencyData(\n          freqData, [1, this.numFrames, this.columnTruncateLength, 1]);\n      let timeDataTensor: tf.Tensor;\n      if (this.includeRawAudio) {\n        const timeData = flattenQueue(this.timeDataQueue);\n        timeDataTensor = getInputTensorFromFrequencyData(\n            timeData, [1, this.numFrames * this.fftSize]);\n      }\n      const shouldRest =\n          await this.spectrogramCallback(freqDataTensor, timeDataTensor);\n      if (shouldRest) {\n        this.tracker.suppress();\n      }\n      tf.dispose([freqDataTensor, timeDataTensor]);\n    }\n  }\n\n  async stop(): Promise<void> {\n    if (this.frameIntervalTask == null) {\n      throw new Error(\n          'Cannot stop because there is no ongoing streaming activity.');\n    }\n    clearInterval(this.frameIntervalTask);\n    this.frameIntervalTask = null;\n    this.analyser.disconnect();\n    this.audioContext.close();\n    if (this.stream != null && this.stream.getTracks().length > 0) {\n      this.stream.getTracks()[0].stop();\n    }\n  }\n\n  setConfig(params: RecognizerParams) {\n    throw new Error(\n        'setConfig() is not implemented for BrowserFftFeatureExtractor.');\n  }\n\n  getFeatures(): Float32Array[] {\n    throw new Error(\n        'getFeatures() is not implemented for ' +\n        'BrowserFftFeatureExtractor. Use the spectrogramCallback ' +\n        'field of the constructor config instead.');\n  }\n}\n\nexport function flattenQueue(queue: Float32Array[]): Float32Array {\n  const frameSize = queue[0].length;\n  const freqData = new Float32Array(queue.length * frameSize);\n  queue.forEach((data, i) => freqData.set(data, i * frameSize));\n  return freqData;\n}\n\nexport function getInputTensorFromFrequencyData(\n    freqData: Float32Array, shape: number[]): tf.Tensor {\n  const vals = new Float32Array(tf.util.sizeFromShape(shape));\n  // If the data is less than the output shape, the rest is padded with zeros.\n  vals.set(freqData, vals.length - freqData.length);\n  return tf.tensor(vals, shape);\n}\n\n/**\n * A class that manages the firing of events based on periods\n * and suppression time.\n */\nexport class Tracker {\n  readonly period: number;\n  readonly suppressionTime: number;\n\n  private counter: number;\n  private suppressionOnset: number;\n\n  /**\n   * Constructor of Tracker.\n   *\n   * @param period The event-firing period, in number of frames.\n   * @param suppressionPeriod The suppression period, in number of frames.\n   */\n  constructor(period: number, suppressionPeriod: number) {\n    this.period = period;\n    this.suppressionTime = suppressionPeriod == null ? 0 : suppressionPeriod;\n    this.counter = 0;\n\n    tf.util.assert(\n        this.period > 0,\n        () => `Expected period to be positive, but got ${this.period}`);\n  }\n\n  /**\n   * Mark a frame.\n   *\n   * @returns Whether the event should be fired at the current frame.\n   */\n  tick(): boolean {\n    this.counter++;\n    const shouldFire = (this.counter % this.period === 0) &&\n        (this.suppressionOnset == null ||\n         this.counter - this.suppressionOnset > this.suppressionTime);\n    return shouldFire;\n  }\n\n  /**\n   * Order the beginning of a supression period.\n   */\n  suppress() {\n    this.suppressionOnset = this.counter;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/**\n * Concatenate a number of ArrayBuffers into one.\n *\n * @param buffers A number of array buffers to concatenate.\n * @returns Result of concatenating `buffers` in order.\n */\nexport function concatenateArrayBuffers(buffers: ArrayBuffer[]): ArrayBuffer {\n  let totalByteLength = 0;\n  buffers.forEach((buffer: ArrayBuffer) => {\n    totalByteLength += buffer.byteLength;\n  });\n\n  const temp = new Uint8Array(totalByteLength);\n  let offset = 0;\n  buffers.forEach((buffer: ArrayBuffer) => {\n    temp.set(new Uint8Array(buffer), offset);\n    offset += buffer.byteLength;\n  });\n  return temp.buffer;\n}\n\n/**\n * Concatenate Float32Arrays.\n *\n * @param xs Float32Arrays to concatenate.\n * @return The result of the concatenation.\n */\nexport function concatenateFloat32Arrays(xs: Float32Array[]): Float32Array {\n  let totalLength = 0;\n  xs.forEach(x => totalLength += x.length);\n  const concatenated = new Float32Array(totalLength);\n  let index = 0;\n  xs.forEach(x => {\n    concatenated.set(x, index);\n    index += x.length;\n  });\n  return concatenated;\n}\n\n/** Encode a string as an ArrayBuffer. */\nexport function string2ArrayBuffer(str: string): ArrayBuffer {\n  if (str == null) {\n    throw new Error('Received null or undefind string');\n  }\n  // NOTE(cais): This implementation is inefficient in terms of memory.\n  // But it works for UTF-8 strings. Just don't use on for very long strings.\n  const strUTF8 = unescape(encodeURIComponent(str));\n  const buf = new Uint8Array(strUTF8.length);\n  for (let i = 0; i < strUTF8.length; ++i) {\n    buf[i] = strUTF8.charCodeAt(i);\n  }\n  return buf.buffer;\n}\n\n/** Decode an ArrayBuffer as a string. */\nexport function arrayBuffer2String(buffer: ArrayBuffer): string {\n  if (buffer == null) {\n    throw new Error('Received null or undefind buffer');\n  }\n  const buf = new Uint8Array(buffer);\n  return decodeURIComponent(escape(String.fromCharCode(...buf)));\n}\n\n/** Generate a pseudo-random UID. */\nexport function getUID(): string {\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n  }\n  return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() +\n      s4() + s4();\n}\n\nexport function getRandomInteger(min: number, max: number): number {\n  return Math.floor((max - min) * Math.random()) + min;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/**\n * Utility functions for training and transfer learning of the speech-commands\n * model.\n */\n\nimport * as tf from '@tensorflow/tfjs';\n\n/**\n * Split feature and target tensors into train and validation (val) splits.\n *\n * Given sufficent number of examples, the train and val sets will be\n * balanced with respect to the classes.\n *\n * @param xs Features tensor, of shape [numExamples, ...].\n * @param ys Targets tensors, of shape [numExamples, numClasses]. Assumed to be\n *   one-hot categorical encoding.\n * @param valSplit A number > 0 and < 1, fraction of examples to use\n *   as the validation set.\n * @returns trainXs: training features tensor; trainYs: training targets\n *   tensor; valXs: validation features tensor; valYs: validation targets\n *   tensor.\n */\nexport function balancedTrainValSplit(\n    xs: tf.Tensor, ys: tf.Tensor, valSplit: number): {\n  trainXs: tf.Tensor,\n  trainYs: tf.Tensor,\n  valXs: tf.Tensor,\n  valYs: tf.Tensor\n} {\n  tf.util.assert(\n      valSplit > 0 && valSplit < 1,\n      () => `validationSplit is expected to be >0 and <1, ` +\n          `but got ${valSplit}`);\n\n  return tf.tidy(() => {\n    const classIndices = ys.argMax(-1).dataSync();\n\n    const indicesByClasses: number[][] = [];\n    for (let i = 0; i < classIndices.length; ++i) {\n      const classIndex = classIndices[i];\n      if (indicesByClasses[classIndex] == null) {\n        indicesByClasses[classIndex] = [];\n      }\n      indicesByClasses[classIndex].push(i);\n    }\n    const numClasses = indicesByClasses.length;\n\n    const trainIndices: number[] = [];\n    const valIndices: number[] = [];\n\n    // Randomly shuffle the list of indices in each array.\n    indicesByClasses.map(classIndices => tf.util.shuffle(classIndices));\n    for (let i = 0; i < numClasses; ++i) {\n      const classIndices = indicesByClasses[i];\n      const cutoff = Math.round(classIndices.length * (1 - valSplit));\n      for (let j = 0; j < classIndices.length; ++j) {\n        if (j < cutoff) {\n          trainIndices.push(classIndices[j]);\n        } else {\n          valIndices.push(classIndices[j]);\n        }\n      }\n    }\n\n    const trainXs = tf.gather(xs, trainIndices);\n    const trainYs = tf.gather(ys, trainIndices);\n    const valXs = tf.gather(xs, valIndices);\n    const valYs = tf.gather(ys, valIndices);\n    return {trainXs, trainYs, valXs, valYs};\n  });\n}\n\n/**\n * Same as balancedTrainValSplit, but for number arrays or Float32Arrays.\n */\nexport function balancedTrainValSplitNumArrays(\n    xs: number[][]|Float32Array[], ys: number[], valSplit: number): {\n  trainXs: number[][]|Float32Array[],\n  trainYs: number[],\n  valXs: number[][]|Float32Array[],\n  valYs: number[]\n} {\n  tf.util.assert(\n      valSplit > 0 && valSplit < 1,\n      () => `validationSplit is expected to be >0 and <1, ` +\n          `but got ${valSplit}`);\n  const isXsFloat32Array = !Array.isArray(xs[0]);\n\n  const classIndices = ys;\n\n  const indicesByClasses: number[][] = [];\n  for (let i = 0; i < classIndices.length; ++i) {\n    const classIndex = classIndices[i];\n    if (indicesByClasses[classIndex] == null) {\n      indicesByClasses[classIndex] = [];\n    }\n    indicesByClasses[classIndex].push(i);\n  }\n  const numClasses = indicesByClasses.length;\n\n  const trainIndices: number[] = [];\n  const valIndices: number[] = [];\n\n  // Randomly shuffle the list of indices in each array.\n  indicesByClasses.map(classIndices => tf.util.shuffle(classIndices));\n  for (let i = 0; i < numClasses; ++i) {\n    const classIndices = indicesByClasses[i];\n    const cutoff = Math.round(classIndices.length * (1 - valSplit));\n    for (let j = 0; j < classIndices.length; ++j) {\n      if (j < cutoff) {\n        trainIndices.push(classIndices[j]);\n      } else {\n        valIndices.push(classIndices[j]);\n      }\n    }\n  }\n\n  if (isXsFloat32Array) {\n    const trainXs: Float32Array[] = [];\n    const trainYs: number[] = [];\n    const valXs: Float32Array[] = [];\n    const valYs: number[] = [];\n    for (const index of trainIndices) {\n      trainXs.push(xs[index] as Float32Array);\n      trainYs.push(ys[index]);\n    }\n    for (const index of valIndices) {\n      valXs.push(xs[index] as Float32Array);\n      valYs.push(ys[index]);\n    }\n    return {trainXs, trainYs, valXs, valYs};\n  } else {\n    const trainXs: number[][] = [];\n    const trainYs: number[] = [];\n    const valXs: number[][] = [];\n    const valYs: number[] = [];\n    for (const index of trainIndices) {\n      trainXs.push(xs[index] as number[]);\n      trainYs.push(ys[index]);\n    }\n    for (const index of valIndices) {\n      valXs.push(xs[index] as number[]);\n      valYs.push(ys[index]);\n    }\n    return {trainXs, trainYs, valXs, valYs};\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs';\nimport {normalize} from './browser_fft_utils';\nimport {arrayBuffer2String, concatenateArrayBuffers, getRandomInteger, getUID, string2ArrayBuffer} from './generic_utils';\nimport {balancedTrainValSplitNumArrays} from './training_utils';\nimport {AudioDataAugmentationOptions, Example, SpectrogramData} from './types';\n\n// Descriptor for serialized dataset files: stands for:\n//   TensorFlow.js Speech-Commands Dataset.\n// DO NOT EVER CHANGE THIS!\nexport const DATASET_SERIALIZATION_DESCRIPTOR = 'TFJSSCDS';\n\n// A version number for the serialization. Since this needs\n// to be encoded within a length-1 Uint8 array, it must be\n//   1. an positive integer.\n//   2. monotonically increasing over its change history.\n// Item 1 is checked by unit tests.\nexport const DATASET_SERIALIZATION_VERSION = 1;\n\n/**\n * Specification for an `Example` (see above).\n *\n * Used for serialization of `Example`.\n */\nexport interface ExampleSpec {\n  /** A label for the example. */\n  label: string;\n\n  /** Number of frames in the spectrogram. */\n  spectrogramNumFrames: number;\n\n  /** The length of each frame in the spectrogram. */\n  spectrogramFrameSize: number;\n\n  /** The key frame index of the spectrogram. */\n  spectrogramKeyFrameIndex?: number;\n\n  /** Number of samples in the raw PCM-format audio (if any). */\n  rawAudioNumSamples?: number;\n\n  /** Sampling rate of the raw audio (if any). */\n  rawAudioSampleRateHz?: number;\n}\n\n/**\n * Serialized Dataset, containing a number of `Example`s in their\n * serialized format.\n *\n * This format consists of a plain-old JSON object as the manifest,\n * along with a flattened binary `ArrayBuffer`. The format facilitates\n * storage and transmission.\n */\nexport interface SerializedExamples {\n  /**\n   * Specifications of the serialized `Example`s, serialized as a string.\n   */\n  manifest: ExampleSpec[];\n\n  /**\n   * Serialized binary data from the `Example`s.\n   *\n   * Including the spectrograms and the raw audio (if any).\n   *\n   * For example, assuming `manifest.length` is `N`, the format of the\n   * `ArrayBuffer` is as follows:\n   *\n   *   [spectrogramData1, rawAudio1 (if any),\n   *    spectrogramData2, rawAudio2 (if any),\n   *    ...\n   *    spectrogramDataN, rawAudioN (if any)]\n   */\n  data: ArrayBuffer;\n}\n\nexport const BACKGROUND_NOISE_TAG = '_background_noise_';\n\n/**\n * Configuration for getting spectrograms as tensors.\n */\nexport interface GetDataConfig extends AudioDataAugmentationOptions {\n  /**\n   * Number of frames.\n   *\n   * This must be smaller than or equal to the # of frames of each\n   * example held by the dataset.\n   *\n   * If the # of frames of an example is greater than this number,\n   * the following heuristics will be used to extra >= 1 examples\n   * of length numFrames from the original example:\n   *\n   *   - If the label of the example is `BAKCGROUND_NOISE_TAG`,\n   *     the example will be splitted into multiple examples using the\n   *     `hopFrames` parameter (see below).\n   *   - If the label of the example is not `BACKGROUND_NOISE_TAG`,\n   *     the example will be splitted into multiple examples that\n   *     all contain the maximum-intensity frame using the `hopFrames`\n   *     parameter.\n   */\n  numFrames?: number;\n\n  /**\n   * Hop length in number of frames.\n   *\n   * Used when splitting a long example into multiple shorter ones.\n   *\n   * Must be provided if any such long examples exist.\n   */\n  hopFrames?: number;\n\n  /**\n   * Whether the spectrogram of each example will be normalized.\n   *\n   * Normalization means:\n   * - Subtracting the mean, and\n   * - Dividing the result by the standard deviation.\n   *\n   * Default: `true`.\n   */\n  normalize?: boolean;\n\n  /**\n   * Whether the examples will be shuffled prior to merged into\n   * `tf.Tensor`s.\n   *\n   * Default: `true`.\n   */\n  shuffle?: boolean;\n\n  /**\n   * Whether to obtain a `tf.data.Datasaet` object.\n   *\n   * Default: `false`.\n   */\n  getDataset?: boolean;\n\n  /**\n   * Batch size for dataset.\n   *\n   * Applicable only if `getDataset === true`.\n   */\n  datasetBatchSize?: number;\n\n  /**\n   * Validation split for the datasaet.\n   *\n   * Applicable only if `getDataset === true`.\n   *\n   * The data will be divided into two fractions of relative sizes\n   * `[1 - datasetValidationSplit, datasetValidationSplit]`, for the\n   * training and validation `tf.data.Dataset` objects, respectively.\n   *\n   * Must be a number between 0 and 1.\n   * Default: 0.15.\n   */\n  datasetValidationSplit?: number;\n}\n\n// tslint:disable-next-line:no-any\nexport type SpectrogramAndTargetsTfDataset = tf.data.Dataset<{}>;\n\n/**\n * A serializable, mutable set of speech/audio `Example`s;\n */\nexport class Dataset {\n  private examples: {[id: string]: Example};\n  private label2Ids: {[label: string]: string[]};\n\n  /**\n   * Constructor of `Dataset`.\n   *\n   * If called with no arguments (i.e., `artifacts` == null), an empty dataset\n   * will be constructed.\n   *\n   * Else, the dataset will be deserialized from `artifacts`.\n   *\n   * @param serialized Optional serialization artifacts to deserialize.\n   */\n  constructor(serialized?: ArrayBuffer) {\n    this.examples = {};\n    this.label2Ids = {};\n    if (serialized != null) {\n      // Deserialize from the provided artifacts.\n      const artifacts = arrayBuffer2SerializedExamples(serialized);\n      let offset = 0;\n      for (let i = 0; i < artifacts.manifest.length; ++i) {\n        const spec = artifacts.manifest[i];\n        let byteLen = spec.spectrogramNumFrames * spec.spectrogramFrameSize;\n        if (spec.rawAudioNumSamples != null) {\n          byteLen += spec.rawAudioNumSamples;\n        }\n        byteLen *= 4;\n        this.addExample(deserializeExample(\n            {spec, data: artifacts.data.slice(offset, offset + byteLen)}));\n        offset += byteLen;\n      }\n    }\n  }\n\n  /**\n   * Add an `Example` to the `Dataset`\n   *\n   * @param example A `Example`, with a label. The label must be a non-empty\n   *   string.\n   * @returns The UID for the added `Example`.\n   */\n  addExample(example: Example): string {\n    tf.util.assert(example != null, () => 'Got null or undefined example');\n    tf.util.assert(\n        example.label != null && example.label.length > 0,\n        () => `Expected label to be a non-empty string, ` +\n            `but got ${JSON.stringify(example.label)}`);\n    const uid = getUID();\n    this.examples[uid] = example;\n    if (!(example.label in this.label2Ids)) {\n      this.label2Ids[example.label] = [];\n    }\n    this.label2Ids[example.label].push(uid);\n    return uid;\n  }\n\n  /**\n   * Merge the incoming dataset into this dataset\n   *\n   * @param dataset The incoming dataset to be merged into this dataset.\n   */\n  merge(dataset: Dataset): void {\n    tf.util.assert(\n        dataset !== this, () => 'Cannot merge a dataset into itself');\n    const vocab = dataset.getVocabulary();\n    for (const word of vocab) {\n      const examples = dataset.getExamples(word);\n      for (const example of examples) {\n        this.addExample(example.example);\n      }\n    }\n  }\n\n  /**\n   * Get a map from `Example` label to number of `Example`s with the label.\n   *\n   * @returns A map from label to number of example counts under that label.\n   */\n  getExampleCounts(): {[label: string]: number} {\n    const counts: {[label: string]: number} = {};\n    for (const uid in this.examples) {\n      const example = this.examples[uid];\n      if (!(example.label in counts)) {\n        counts[example.label] = 0;\n      }\n      counts[example.label]++;\n    }\n    return counts;\n  }\n\n  /**\n   * Get all examples of a given label, with their UIDs.\n   *\n   * @param label The requested label.\n   * @return All examples of the given `label`, along with their UIDs.\n   *   The examples are sorted in the order in which they are added to the\n   *   `Dataset`.\n   * @throws Error if label is `null` or `undefined`.\n   */\n  getExamples(label: string): Array<{uid: string, example: Example}> {\n    tf.util.assert(\n        label != null,\n        () =>\n            `Expected label to be a string, but got ${JSON.stringify(label)}`);\n    tf.util.assert(\n        label in this.label2Ids,\n        () => `No example of label \"${label}\" exists in dataset`);\n    const output: Array<{uid: string, example: Example}> = [];\n    this.label2Ids[label].forEach(id => {\n      output.push({uid: id, example: this.examples[id]});\n    });\n    return output;\n  }\n\n  /**\n   * Get all examples and labels as tensors.\n   *\n   * - If `label` is provided and exists in the vocabulary of the `Dataset`,\n   *   the spectrograms of all `Example`s under the `label` will be returned\n   *   as a 4D `tf.Tensor` as `xs`. The shape of the `tf.Tensor` will be\n   *     `[numExamples, numFrames, frameSize, 1]`\n   *   where\n   *     - `numExamples` is the number of `Example`s with the label\n   *     - `numFrames` is the number of frames in each spectrogram\n   *     - `frameSize` is the size of each spectrogram frame.\n   *   No label Tensor will be returned.\n   * - If `label` is not provided, all `Example`s will be returned as `xs`.\n   *   In addition, `ys` will contain a one-hot encoded list of labels.\n   *   - The shape of `xs` will be: `[numExamples, numFrames, frameSize, 1]`\n   *   - The shape of `ys` will be: `[numExamples, vocabularySize]`.\n   *\n   * @returns If `config.getDataset` is `true`, returns two `tf.data.Dataset`\n   *   objects, one for training and one for validation.\n   *   Else, xs` and `ys` tensors. See description above.\n   * @throws Error\n   *   - if not all the involved spectrograms have matching `numFrames` and\n   *     `frameSize`, or\n   *   - if `label` is provided and is not present in the vocabulary of the\n   *     `Dataset`, or\n   *   - if the `Dataset` is currently empty.\n   */\n  getData(label?: string, config?: GetDataConfig): {\n    xs: tf.Tensor4D,\n    ys?: tf.Tensor2D\n  }|[SpectrogramAndTargetsTfDataset, SpectrogramAndTargetsTfDataset] {\n    tf.util.assert(\n        this.size() > 0,\n        () =>\n            `Cannot get spectrograms as tensors because the dataset is empty`);\n    const vocab = this.getVocabulary();\n    if (label != null) {\n      tf.util.assert(\n          vocab.indexOf(label) !== -1,\n          () => `Label ${label} is not in the vocabulary ` +\n              `(${JSON.stringify(vocab)})`);\n    } else {\n      // If all words are requested, there must be at least two words in the\n      // vocabulary to make one-hot encoding possible.\n      tf.util.assert(\n          vocab.length > 1,\n          () => `One-hot encoding of labels requires the vocabulary to have ` +\n              `at least two words, but it has only ${vocab.length} word.`);\n    }\n\n    if (config == null) {\n      config = {};\n    }\n\n    // Get the numFrames lengths of all the examples currently held by the\n    // dataset.\n    const sortedUniqueNumFrames = this.getSortedUniqueNumFrames();\n    let numFrames: number;\n    let hopFrames: number;\n    if (sortedUniqueNumFrames.length === 1) {\n      numFrames = config.numFrames == null ? sortedUniqueNumFrames[0] :\n                                             config.numFrames;\n      hopFrames = config.hopFrames == null ? 1 : config.hopFrames;\n    } else {\n      numFrames = config.numFrames;\n      tf.util.assert(\n          numFrames != null && Number.isInteger(numFrames) && numFrames > 0,\n          () => `There are ${\n                    sortedUniqueNumFrames.length} unique lengths among ` +\n              `the ${this.size()} examples of this Dataset, hence numFrames ` +\n              `is required. But it is not provided.`);\n      tf.util.assert(\n          numFrames <= sortedUniqueNumFrames[0],\n          () => `numFrames (${numFrames}) exceeds the minimum numFrames ` +\n              `(${sortedUniqueNumFrames[0]}) among the examples of ` +\n              `the Dataset.`);\n\n      hopFrames = config.hopFrames;\n      tf.util.assert(\n          hopFrames != null && Number.isInteger(hopFrames) && hopFrames > 0,\n          () => `There are ${\n                    sortedUniqueNumFrames.length} unique lengths among ` +\n              `the ${this.size()} examples of this Dataset, hence hopFrames ` +\n              `is required. But it is not provided.`);\n    }\n\n    // Normalization is performed by default.\n    const toNormalize = config.normalize == null ? true : config.normalize;\n\n    return tf.tidy(() => {\n      let xTensors: tf.Tensor3D[] = [];\n      let xArrays: Float32Array[] = [];\n\n      let labelIndices: number[] = [];\n      let uniqueFrameSize: number;\n      for (let i = 0; i < vocab.length; ++i) {\n        const currentLabel = vocab[i];\n        if (label != null && currentLabel !== label) {\n          continue;\n        }\n        const ids = this.label2Ids[currentLabel];\n        for (const id of ids) {\n          const example = this.examples[id];\n          const spectrogram = example.spectrogram;\n          const frameSize = spectrogram.frameSize;\n          if (uniqueFrameSize == null) {\n            uniqueFrameSize = frameSize;\n          } else {\n            tf.util.assert(\n                frameSize === uniqueFrameSize,\n                () => `Mismatch in frameSize  ` +\n                    `(${frameSize} vs ${uniqueFrameSize})`);\n          }\n\n          const snippetLength = spectrogram.data.length / frameSize;\n          let focusIndex = null;\n          if (currentLabel !== BACKGROUND_NOISE_TAG) {\n            focusIndex = spectrogram.keyFrameIndex == null ?\n                getMaxIntensityFrameIndex(spectrogram).dataSync()[0] :\n                spectrogram.keyFrameIndex;\n          }\n          // TODO(cais): See if we can get rid of dataSync();\n\n          const snippet =\n              tf.tensor3d(spectrogram.data, [snippetLength, frameSize, 1]);\n          const windows =\n              getValidWindows(snippetLength, focusIndex, numFrames, hopFrames);\n          for (const window of windows) {\n            const windowedSnippet = tf.tidy(() => {\n              const output = snippet.slice(\n                  [window[0], 0, 0], [window[1] - window[0], -1, -1]);\n              return toNormalize ? normalize(output) : output;\n            });\n            if (config.getDataset) {\n              // TODO(cais): See if we can do away with dataSync();\n              // TODO(cais): Shuffling?\n              xArrays.push(windowedSnippet.dataSync() as Float32Array);\n            } else {\n              xTensors.push(windowedSnippet as tf.Tensor3D);\n            }\n            if (label == null) {\n              labelIndices.push(i);\n            }\n          }\n          tf.dispose(snippet);  // For memory saving.\n        }\n      }\n\n      if (config.augmentByMixingNoiseRatio != null) {\n        this.augmentByMixingNoise(\n            config.getDataset ? xArrays :\n                                xTensors as Array<Float32Array|tf.Tensor>,\n            labelIndices, config.augmentByMixingNoiseRatio);\n      }\n\n      const shuffle = config.shuffle == null ? true : config.shuffle;\n      if (config.getDataset) {\n        const batchSize =\n            config.datasetBatchSize == null ? 32 : config.datasetBatchSize;\n\n        // Split the data into two splits: training and validation.\n        const valSplit = config.datasetValidationSplit == null ?\n            0.15 :\n            config.datasetValidationSplit;\n        tf.util.assert(\n            valSplit > 0 && valSplit < 1,\n            () => `Invalid dataset validation split: ${valSplit}`);\n\n        const zippedXandYArrays =\n            xArrays.map((xArray, i) => [xArray, labelIndices[i]]);\n        tf.util.shuffle(\n            zippedXandYArrays);  // Shuffle the data before splitting.\n        xArrays = zippedXandYArrays.map(item => item[0]) as Float32Array[];\n        const yArrays = zippedXandYArrays.map(item => item[1]) as number[];\n        const {trainXs, trainYs, valXs, valYs} =\n            balancedTrainValSplitNumArrays(xArrays, yArrays, valSplit);\n\n        // TODO(cais): The typing around Float32Array is not working properly\n        // for tf.data currently. Tighten the types when the tf.data bug is\n        // fixed.\n        // tslint:disable:no-any\n        const xTrain =\n            tf.data.array(trainXs as any).map(x => tf.tensor3d(x as any, [\n              numFrames, uniqueFrameSize, 1\n            ]));\n        const yTrain = tf.data.array(trainYs).map(\n            y => tf.oneHot([y], vocab.length).squeeze([0]));\n        // TODO(cais): See if we can tighten the typing.\n        let trainDataset = tf.data.zip({xs: xTrain, ys: yTrain});\n        if (shuffle) {\n          // Shuffle the dataset.\n          trainDataset = trainDataset.shuffle(xArrays.length);\n        }\n        trainDataset = trainDataset.batch(batchSize).prefetch(4);\n\n        const xVal =\n            tf.data.array(valXs as any).map(x => tf.tensor3d(x as any, [\n              numFrames, uniqueFrameSize, 1\n            ]));\n        const yVal = tf.data.array(valYs).map(\n            y => tf.oneHot([y], vocab.length).squeeze([0]));\n        let valDataset = tf.data.zip({xs: xVal, ys: yVal});\n        valDataset = valDataset.batch(batchSize).prefetch(4);\n        // tslint:enable:no-any\n\n        // tslint:disable-next-line:no-any\n        return [trainDataset, valDataset] as any;\n      } else {\n        if (shuffle) {\n          // Shuffle the data.\n          const zipped: Array<{x: tf.Tensor3D, y: number}> = [];\n          xTensors.forEach((xTensor, i) => {\n            zipped.push({x: xTensor, y: labelIndices[i]});\n          });\n          tf.util.shuffle(zipped);\n          xTensors = zipped.map(item => item.x);\n          labelIndices = zipped.map(item => item.y);\n        }\n\n        const targets = label == null ?\n            tf.oneHot(tf.tensor1d(labelIndices, 'int32'), vocab.length)\n                .asType('float32') :\n            undefined;\n        return {\n          xs: tf.stack(xTensors) as tf.Tensor4D,\n          ys: targets as tf.Tensor2D\n        };\n      }\n    });\n  }\n\n  private augmentByMixingNoise<T extends tf.Tensor|Float32Array>(\n      xs: T[], labelIndices: number[], ratio: number): void {\n    if (xs == null || xs.length === 0) {\n      throw new Error(\n          `Cannot perform augmentation because data is null or empty`);\n    }\n    const isTypedArray = xs[0] instanceof Float32Array;\n\n    const vocab = this.getVocabulary();\n    const noiseExampleIndices: number[] = [];\n    const wordExampleIndices: number[] = [];\n    for (let i = 0; i < labelIndices.length; ++i) {\n      if (vocab[labelIndices[i]] === BACKGROUND_NOISE_TAG) {\n        noiseExampleIndices.push(i);\n      } else {\n        wordExampleIndices.push(i);\n      }\n    }\n    if (noiseExampleIndices.length === 0) {\n      throw new Error(\n          `Cannot perform augmentation by mixing with noise when ` +\n          `there is no example with label ${BACKGROUND_NOISE_TAG}`);\n    }\n\n    const mixedXTensors: Array<tf.Tensor|Float32Array> = [];\n    const mixedLabelIndices: number[] = [];\n    for (const index of wordExampleIndices) {\n      const noiseIndex =  // Randomly sample from the noises, with replacement.\n          noiseExampleIndices[getRandomInteger(0, noiseExampleIndices.length)];\n      const signalTensor = isTypedArray ?\n          tf.tensor1d(xs[index] as Float32Array) :\n          xs[index] as tf.Tensor;\n      const noiseTensor = isTypedArray ?\n          tf.tensor1d(xs[noiseIndex] as Float32Array) :\n          xs[noiseIndex] as tf.Tensor;\n      const mixed: tf.Tensor =\n          tf.tidy(() => normalize(signalTensor.add(noiseTensor.mul(ratio))));\n      if (isTypedArray) {\n        mixedXTensors.push(mixed.dataSync() as Float32Array);\n      } else {\n        mixedXTensors.push(mixed);\n      }\n      mixedLabelIndices.push(labelIndices[index]);\n    }\n    console.log(\n        `Data augmentation: mixing noise: added ${mixedXTensors.length} ` +\n        `examples`);\n    mixedXTensors.forEach(tensor => xs.push(tensor as T));\n    labelIndices.push(...mixedLabelIndices);\n  }\n\n  private getSortedUniqueNumFrames(): number[] {\n    const numFramesSet = new Set<number>();\n    const vocab = this.getVocabulary();\n    for (let i = 0; i < vocab.length; ++i) {\n      const label = vocab[i];\n      const ids = this.label2Ids[label];\n      for (const id of ids) {\n        const spectrogram = this.examples[id].spectrogram;\n        const numFrames = spectrogram.data.length / spectrogram.frameSize;\n        numFramesSet.add(numFrames);\n      }\n    }\n    const uniqueNumFrames = [...numFramesSet];\n    uniqueNumFrames.sort();\n    return uniqueNumFrames;\n  }\n\n  /**\n   * Remove an example from the `Dataset`.\n   *\n   * @param uid The UID of the example to remove.\n   * @throws Error if the UID doesn't exist in the `Dataset`.\n   */\n  removeExample(uid: string): void {\n    if (!(uid in this.examples)) {\n      throw new Error(`Nonexistent example UID: ${uid}`);\n    }\n    const label = this.examples[uid].label;\n    delete this.examples[uid];\n    const index = this.label2Ids[label].indexOf(uid);\n    this.label2Ids[label].splice(index, 1);\n    if (this.label2Ids[label].length === 0) {\n      delete this.label2Ids[label];\n    }\n  }\n\n  /**\n   * Set the key frame index of a given example.\n   *\n   * @param uid The UID of the example of which the `keyFrameIndex` is to be\n   *   set.\n   * @param keyFrameIndex The desired value of the `keyFrameIndex`. Must\n   *   be >= 0, < the number of frames of the example, and an integer.\n   * @throws Error If the UID and/or the `keyFrameIndex` value is invalid.\n   */\n  setExampleKeyFrameIndex(uid: string, keyFrameIndex: number) {\n    if (!(uid in this.examples)) {\n      throw new Error(`Nonexistent example UID: ${uid}`);\n    }\n    const spectrogram = this.examples[uid].spectrogram;\n    const numFrames = spectrogram.data.length / spectrogram.frameSize;\n    tf.util.assert(\n        keyFrameIndex >= 0 && keyFrameIndex < numFrames &&\n            Number.isInteger(keyFrameIndex),\n        () => `Invalid keyFrameIndex: ${keyFrameIndex}. ` +\n            `Must be >= 0, < ${numFrames}, and an integer.`);\n    spectrogram.keyFrameIndex = keyFrameIndex;\n  }\n\n  /**\n   * Get the total number of `Example` currently held by the `Dataset`.\n   *\n   * @returns Total `Example` count.\n   */\n  size(): number {\n    return Object.keys(this.examples).length;\n  }\n\n  /**\n   * Get the total duration of the `Example` currently held by `Dataset`,\n   *\n   * in milliseconds.\n   *\n   * @return Total duration in milliseconds.\n   */\n  durationMillis(): number {\n    let durMillis = 0;\n    const DEFAULT_FRAME_DUR_MILLIS = 23.22;\n    for (const key in this.examples) {\n      const spectrogram = this.examples[key].spectrogram;\n      const frameDurMillis =\n          spectrogram.frameDurationMillis | DEFAULT_FRAME_DUR_MILLIS;\n      durMillis +=\n          spectrogram.data.length / spectrogram.frameSize * frameDurMillis;\n    }\n    return durMillis;\n  }\n\n  /**\n   * Query whether the `Dataset` is currently empty.\n   *\n   * I.e., holds zero examples.\n   *\n   * @returns Whether the `Dataset` is currently empty.\n   */\n  empty(): boolean {\n    return this.size() === 0;\n  }\n\n  /**\n   * Remove all `Example`s from the `Dataset`.\n   */\n  clear(): void {\n    this.examples = {};\n  }\n\n  /**\n   * Get the list of labels among all `Example`s the `Dataset` currently holds.\n   *\n   * @returns A sorted Array of labels, for the unique labels that belong to all\n   *   `Example`s currently held by the `Dataset`.\n   */\n  getVocabulary(): string[] {\n    const vocab = new Set<string>();\n    for (const uid in this.examples) {\n      const example = this.examples[uid];\n      vocab.add(example.label);\n    }\n    const sortedVocab = [...vocab];\n    sortedVocab.sort();\n    return sortedVocab;\n  }\n\n  /**\n   * Serialize the `Dataset`.\n   *\n   * The `Examples` are sorted in the following order:\n   *   - First, the labels in the vocabulary are sorted.\n   *   - Second, the `Example`s for every label are sorted by the order in\n   *     which they are added to this `Dataset`.\n   *\n   * @param wordLabels Optional word label(s) to serialize. If specified, only\n   *   the examples with labels matching the argument will be serialized. If\n   *   any specified word label does not exist in the vocabulary of this\n   *   dataset, an Error will be thrown.\n   * @returns A `ArrayBuffer` object amenable to transmission and storage.\n   */\n  serialize(wordLabels?: string|string[]): ArrayBuffer {\n    const vocab = this.getVocabulary();\n    tf.util.assert(!this.empty(), () => `Cannot serialize empty Dataset`);\n\n    if (wordLabels != null) {\n      if (!Array.isArray(wordLabels)) {\n        wordLabels = [wordLabels];\n      }\n      wordLabels.forEach(wordLabel => {\n        if (vocab.indexOf(wordLabel) === -1) {\n          throw new Error(\n              `Word label \"${wordLabel}\" does not exist in the ` +\n              `vocabulary of this dataset. The vocabulary is: ` +\n              `${JSON.stringify(vocab)}.`);\n        }\n      });\n    }\n\n    const manifest: ExampleSpec[] = [];\n    const buffers: ArrayBuffer[] = [];\n    for (const label of vocab) {\n      if (wordLabels != null && wordLabels.indexOf(label) === -1) {\n        continue;\n      }\n      const ids = this.label2Ids[label];\n      for (const id of ids) {\n        const artifact = serializeExample(this.examples[id]);\n        manifest.push(artifact.spec);\n        buffers.push(artifact.data);\n      }\n    }\n    return serializedExamples2ArrayBuffer(\n        {manifest, data: concatenateArrayBuffers(buffers)});\n  }\n}\n\n/** Serialize an `Example`. */\nexport function serializeExample(example: Example):\n    {spec: ExampleSpec, data: ArrayBuffer} {\n  const hasRawAudio = example.rawAudio != null;\n  const spec: ExampleSpec = {\n    label: example.label,\n    spectrogramNumFrames:\n        example.spectrogram.data.length / example.spectrogram.frameSize,\n    spectrogramFrameSize: example.spectrogram.frameSize,\n  };\n  if (example.spectrogram.keyFrameIndex != null) {\n    spec.spectrogramKeyFrameIndex = example.spectrogram.keyFrameIndex;\n  }\n\n  let data = example.spectrogram.data.buffer.slice(0);\n  if (hasRawAudio) {\n    spec.rawAudioNumSamples = example.rawAudio.data.length;\n    spec.rawAudioSampleRateHz = example.rawAudio.sampleRateHz;\n\n    // Account for the fact that the data are all float32.\n    data = concatenateArrayBuffers([data, example.rawAudio.data.buffer]);\n  }\n  return {spec, data};\n}\n\n/** Deserialize an `Example`. */\nexport function deserializeExample(\n    artifact: {spec: ExampleSpec, data: ArrayBuffer}): Example {\n  const spectrogram: SpectrogramData = {\n    frameSize: artifact.spec.spectrogramFrameSize,\n    data: new Float32Array(artifact.data.slice(\n        0,\n        4 * artifact.spec.spectrogramFrameSize *\n            artifact.spec.spectrogramNumFrames))\n  };\n  if (artifact.spec.spectrogramKeyFrameIndex != null) {\n    spectrogram.keyFrameIndex = artifact.spec.spectrogramKeyFrameIndex;\n  }\n  const ex: Example = {label: artifact.spec.label, spectrogram};\n  if (artifact.spec.rawAudioNumSamples != null) {\n    ex.rawAudio = {\n      sampleRateHz: artifact.spec.rawAudioSampleRateHz,\n      data: new Float32Array(artifact.data.slice(\n          4 * artifact.spec.spectrogramFrameSize *\n          artifact.spec.spectrogramNumFrames))\n    };\n  }\n  return ex;\n}\n\n/**\n * Encode intermediate serialization format as an ArrayBuffer.\n *\n * Format of the binary ArrayBuffer:\n *   1. An 8-byte descriptor (see above).\n *   2. A 4-byte version number as Uint32.\n *   3. A 4-byte number for the byte length of the JSON manifest.\n *   4. The encoded JSON manifest\n *   5. The binary data of the spectrograms, and raw audio (if any).\n *\n * @param serialized: Intermediate serialization format of a dataset.\n * @returns The binary conversion result as an ArrayBuffer.\n */\nfunction serializedExamples2ArrayBuffer(serialized: SerializedExamples):\n    ArrayBuffer {\n  const manifestBuffer =\n      string2ArrayBuffer(JSON.stringify(serialized.manifest));\n\n  const descriptorBuffer = string2ArrayBuffer(DATASET_SERIALIZATION_DESCRIPTOR);\n  const version = new Uint32Array([DATASET_SERIALIZATION_VERSION]);\n  const manifestLength = new Uint32Array([manifestBuffer.byteLength]);\n  const headerBuffer = concatenateArrayBuffers(\n      [descriptorBuffer, version.buffer, manifestLength.buffer]);\n\n  return concatenateArrayBuffers(\n      [headerBuffer, manifestBuffer, serialized.data]);\n}\n\n/** Decode an ArrayBuffer as intermediate serialization format. */\nexport function arrayBuffer2SerializedExamples(buffer: ArrayBuffer):\n    SerializedExamples {\n  tf.util.assert(buffer != null, () => 'Received null or undefined buffer');\n  // Check descriptor.\n  let offset = 0;\n  const descriptor = arrayBuffer2String(\n      buffer.slice(offset, DATASET_SERIALIZATION_DESCRIPTOR.length));\n  tf.util.assert(\n      descriptor === DATASET_SERIALIZATION_DESCRIPTOR,\n      () => `Deserialization error: Invalid descriptor`);\n  offset += DATASET_SERIALIZATION_DESCRIPTOR.length;\n  // Skip the version part for now. It may be used in the future.\n  offset += 4;\n\n  // Extract the length of the encoded manifest JSON as a Uint32.\n  const manifestLength = new Uint32Array(buffer, offset, 1);\n  offset += 4;\n  const manifestBeginByte = offset;\n  offset = manifestBeginByte + manifestLength[0];\n  const manifestBytes = buffer.slice(manifestBeginByte, offset);\n  const manifestString = arrayBuffer2String(manifestBytes);\n  const manifest = JSON.parse(manifestString);\n  const data = buffer.slice(offset);\n  return {manifest, data};\n}\n\n/**\n * Get valid windows in a long snippet.\n *\n * Each window is represented by an inclusive left index and an exclusive\n * right index.\n *\n * @param snippetLength Long of the entire snippet. Must be a positive\n *   integer.\n * @param focusIndex Optional. If `null` or `undefined`, an array of\n *   evenly-spaced windows will be generated. The array of windows will\n *   start from the first possible location (i.e., [0, windowLength]).\n *   If not `null` or `undefined`, must be an integer >= 0 and < snippetLength.\n * @param windowLength Length of each window. Must be a positive integer and\n *   <= snippetLength.\n * @param windowHop Hops between successsive windows. Must be a positive\n *   integer.\n * @returns An array of [beginIndex, endIndex] pairs.\n */\nexport function getValidWindows(\n    snippetLength: number, focusIndex: number, windowLength: number,\n    windowHop: number): Array<[number, number]> {\n  tf.util.assert(\n      Number.isInteger(snippetLength) && snippetLength > 0,\n      () =>\n          `snippetLength must be a positive integer, but got ${snippetLength}`);\n  if (focusIndex != null) {\n    tf.util.assert(\n        Number.isInteger(focusIndex) && focusIndex >= 0,\n        () =>\n            `focusIndex must be a non-negative integer, but got ${focusIndex}`);\n  }\n  tf.util.assert(\n      Number.isInteger(windowLength) && windowLength > 0,\n      () => `windowLength must be a positive integer, but got ${windowLength}`);\n  tf.util.assert(\n      Number.isInteger(windowHop) && windowHop > 0,\n      () => `windowHop must be a positive integer, but got ${windowHop}`);\n  tf.util.assert(\n      windowLength <= snippetLength,\n      () => `windowLength (${windowLength}) exceeds snippetLength ` +\n          `(${snippetLength})`);\n  tf.util.assert(\n      focusIndex < snippetLength,\n      () => `focusIndex (${focusIndex}) equals or exceeds snippetLength ` +\n          `(${snippetLength})`);\n\n  if (windowLength === snippetLength) {\n    return [[0, snippetLength]];\n  }\n\n  const windows: Array<[number, number]> = [];\n\n  if (focusIndex == null) {\n    // Deal with the special case of no focus frame:\n    // Output an array of evenly-spaced windows, starting from\n    // the first possible location.\n    let begin = 0;\n    while (begin + windowLength <= snippetLength) {\n      windows.push([begin, begin + windowLength]);\n      begin += windowHop;\n    }\n    return windows;\n  }\n\n  const leftHalf = Math.floor(windowLength / 2);\n  let left = focusIndex - leftHalf;\n  if (left < 0) {\n    left = 0;\n  } else if (left + windowLength > snippetLength) {\n    left = snippetLength - windowLength;\n  }\n\n  while (true) {\n    if (left - windowHop < 0 || focusIndex >= left - windowHop + windowLength) {\n      break;\n    }\n    left -= windowHop;\n  }\n\n  while (left + windowLength <= snippetLength) {\n    if (focusIndex < left) {\n      break;\n    }\n    windows.push([left, left + windowLength]);\n    left += windowHop;\n  }\n  return windows;\n}\n\n/**\n * Calculate an intensity profile from a spectrogram.\n *\n * The intensity at each time frame is caclulated by simply averaging all the\n * spectral values that belong to that time frame.\n *\n * @param spectrogram The input spectrogram.\n * @returns The temporal profile of the intensity as a 1D tf.Tensor of shape\n *   `[numFrames]`.\n */\nexport function spectrogram2IntensityCurve(spectrogram: SpectrogramData):\n    tf.Tensor {\n  return tf.tidy(() => {\n    const numFrames = spectrogram.data.length / spectrogram.frameSize;\n    const x = tf.tensor2d(spectrogram.data, [numFrames, spectrogram.frameSize]);\n    return x.mean(-1);\n  });\n}\n\n/**\n * Get the index to the maximum intensity frame.\n *\n * The intensity of each time frame is calculated as the arithmetic mean of\n * all the spectral values belonging to that time frame.\n *\n * @param spectrogram The input spectrogram.\n * @returns The index to the time frame containing the maximum intensity.\n */\nexport function getMaxIntensityFrameIndex(spectrogram: SpectrogramData):\n    tf.Scalar {\n  return tf.tidy(() => spectrogram2IntensityCurve(spectrogram).argMax());\n}\n","/** @license See the LICENSE file. */\n\n// This code is auto-generated, do not modify this file!\nconst version = '0.4.1';\nexport {version};\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs';\n\nimport {BrowserFftFeatureExtractor, SpectrogramCallback} from './browser_fft_extractor';\nimport {loadMetadataJson, normalize, normalizeFloat32Array} from './browser_fft_utils';\nimport {BACKGROUND_NOISE_TAG, Dataset} from './dataset';\nimport {concatenateFloat32Arrays} from './generic_utils';\nimport {balancedTrainValSplit} from './training_utils';\nimport {AudioDataAugmentationOptions, EvaluateConfig, EvaluateResult, Example, ExampleCollectionOptions, RecognizeConfig, RecognizerCallback, RecognizerParams, ROCCurve, SpectrogramData, SpeechCommandRecognizer, SpeechCommandRecognizerMetadata, SpeechCommandRecognizerResult, StreamingRecognitionConfig, TransferLearnConfig, TransferSpeechCommandRecognizer} from './types';\nimport {version} from './version';\n\nexport const UNKNOWN_TAG = '_unknown_';\n\n// Key to the local-storage item that holds a map from model name to word\n// list.\nexport const SAVED_MODEL_METADATA_KEY =\n    'tfjs-speech-commands-saved-model-metadata';\nexport const SAVE_PATH_PREFIX = 'indexeddb://tfjs-speech-commands-model/';\n\n// Export a variable for injection during unit testing.\n// tslint:disable-next-line:no-any\nexport let localStorageWrapper = {\n  localStorage: typeof window === 'undefined' ? null : window.localStorage\n};\n\nexport function getMajorAndMinorVersion(version: string) {\n  const versionItems = version.split('.');\n  return versionItems.slice(0, 2).join('.');\n}\n\n/**\n * Default window hop ratio used for extracting multiple\n * windows from a long spectrogram.\n */\nconst DEFAULT_WINDOW_HOP_RATIO = 0.25;\n\n/**\n * Speech-Command Recognizer using browser-native (WebAudio) spectral featutres.\n */\nexport class BrowserFftSpeechCommandRecognizer implements\n    SpeechCommandRecognizer {\n  static readonly VALID_VOCABULARY_NAMES: string[] = ['18w', 'directional4w'];\n  static readonly DEFAULT_VOCABULARY_NAME = '18w';\n\n  readonly MODEL_URL_PREFIX =\n      `https://storage.googleapis.com/tfjs-models/tfjs/speech-commands/v${\n          getMajorAndMinorVersion(version)}/browser_fft`;\n\n  private readonly SAMPLE_RATE_HZ = 44100;\n  private readonly FFT_SIZE = 1024;\n  private readonly DEFAULT_SUPPRESSION_TIME_MILLIS = 0;\n\n  model: tf.LayersModel;\n  modelWithEmbeddingOutput: tf.LayersModel;\n  readonly vocabulary: string;\n  readonly parameters: RecognizerParams;\n  protected words: string[];\n\n  protected streaming = false;\n\n  protected nonBatchInputShape: [number, number, number];\n  private elementsPerExample: number;\n  protected audioDataExtractor: BrowserFftFeatureExtractor;\n\n  private transferRecognizers:\n      {[name: string]: TransferBrowserFftSpeechCommandRecognizer} = {};\n\n  private modelArtifactsOrURL: tf.io.ModelArtifacts|string;\n  private metadataOrURL: SpeechCommandRecognizerMetadata|string;\n\n  // The second-last dense layer in the base model.\n  // To be used for unfreezing during fine-tuning.\n  protected secondLastBaseDenseLayer: tf.layers.Layer;\n\n  /**\n   * Constructor of BrowserFftSpeechCommandRecognizer.\n   *\n   * @param vocabulary An optional vocabulary specifier. Mutually exclusive\n   *   with `modelURL` and `metadataURL`.\n   * @param modelArtifactsOrURL An optional, custom model URL pointing to a\n   *     model.json, or modelArtifacts in the format of `tf.io.ModelArtifacts`.\n   *   file. Supported schemes: http://, https://, and node.js-only: file://.\n   *   Mutually exclusive with `vocabulary`. If provided, `metadatURL`\n   *   most also be provided.\n   * @param metadataOrURL A custom metadata URL pointing to a metadata.json\n   *   file. Or it can be a metadata JSON object itself. Must be provided\n   *   together with `modelArtifactsOrURL`.\n   */\n  constructor(\n      vocabulary?: string, modelArtifactsOrURL?: tf.io.ModelArtifacts|string,\n      metadataOrURL?: SpeechCommandRecognizerMetadata|string) {\n    // TODO(cais): Consolidate the fields into a single config object when\n    // upgrading to v1.0.\n    tf.util.assert(\n        modelArtifactsOrURL == null && metadataOrURL == null ||\n            modelArtifactsOrURL != null && metadataOrURL != null,\n        () => `modelURL and metadataURL must be both provided or ` +\n            `both not provided.`);\n    if (modelArtifactsOrURL == null) {\n      if (vocabulary == null) {\n        vocabulary = BrowserFftSpeechCommandRecognizer.DEFAULT_VOCABULARY_NAME;\n      } else {\n        tf.util.assert(\n            BrowserFftSpeechCommandRecognizer.VALID_VOCABULARY_NAMES.indexOf(\n                vocabulary) !== -1,\n            () => `Invalid vocabulary name: '${vocabulary}'`);\n      }\n      this.vocabulary = vocabulary;\n      this.modelArtifactsOrURL =\n          `${this.MODEL_URL_PREFIX}/${this.vocabulary}/model.json`;\n      this.metadataOrURL =\n          `${this.MODEL_URL_PREFIX}/${this.vocabulary}/metadata.json`;\n    } else {\n      tf.util.assert(\n          vocabulary == null,\n          () => `vocabulary name must be null or undefined when modelURL is ` +\n              `provided`);\n      this.modelArtifactsOrURL = modelArtifactsOrURL;\n      this.metadataOrURL = metadataOrURL;\n    }\n\n    this.parameters = {\n      sampleRateHz: this.SAMPLE_RATE_HZ,\n      fftSize: this.FFT_SIZE\n    };\n  }\n\n  /**\n   * Start streaming recognition.\n   *\n   * To stop the recognition, use `stopListening()`.\n   *\n   * Example: TODO(cais): Add exapmle code snippet.\n   *\n   * @param callback The callback invoked whenever a word is recognized\n   *   with a probability score greater than `config.probabilityThreshold`.\n   *   It has the signature:\n   *     (result: SpeechCommandRecognizerResult) => Promise<void>\n   *   wherein result has the two fields:\n   *   - scores: A Float32Array that contains the probability scores for all\n   *     the words.\n   *   - spectrogram: The spectrogram data, provided only if\n   *     `config.includeSpectrogram` is `true`.\n   * @param config The configurations for the streaming recognition to\n   *   be started.\n   *   The `modelName` field of `config` specifies the model to be used for\n   *   online recognition. If not specified, it defaults to the name of the\n   *   base model ('base'), i.e., the pretrained model not from transfer\n   *   learning. If the recognizer instance has one or more transfer-learning\n   *   models ready (as a result of calls to `collectTransferExample`\n   *   and `trainTransferModel`), you can let this call use that\n   *   model for prediction by specifying the corresponding `modelName`.\n   * @throws Error, if streaming recognition is already started or\n   *   if `config` contains invalid values.\n   */\n  async listen(\n      callback: RecognizerCallback,\n      config?: StreamingRecognitionConfig): Promise<void> {\n    if (this.streaming) {\n      throw new Error(\n          'Cannot start streaming again when streaming is ongoing.');\n    }\n\n    await this.ensureModelLoaded();\n\n    if (config == null) {\n      config = {};\n    }\n    let probabilityThreshold =\n        config.probabilityThreshold == null ? 0 : config.probabilityThreshold;\n    if (config.includeEmbedding) {\n      // Override probability threshold to 0 if includeEmbedding is true.\n      probabilityThreshold = 0;\n    }\n    tf.util.assert(\n        probabilityThreshold >= 0 && probabilityThreshold <= 1,\n        () => `Invalid probabilityThreshold value: ${probabilityThreshold}`);\n    let invokeCallbackOnNoiseAndUnknown =\n        config.invokeCallbackOnNoiseAndUnknown == null ?\n        false :\n        config.invokeCallbackOnNoiseAndUnknown;\n    if (config.includeEmbedding) {\n      // Override invokeCallbackOnNoiseAndUnknown threshold to true if\n      // includeEmbedding is true.\n      invokeCallbackOnNoiseAndUnknown = true;\n    }\n\n    if (config.suppressionTimeMillis < 0) {\n      throw new Error(\n          `suppressionTimeMillis is expected to be >= 0, ` +\n          `but got ${config.suppressionTimeMillis}`);\n    }\n\n    const overlapFactor =\n        config.overlapFactor == null ? 0.5 : config.overlapFactor;\n    tf.util.assert(\n        overlapFactor >= 0 && overlapFactor < 1,\n        () => `Expected overlapFactor to be >= 0 and < 1, but got ${\n            overlapFactor}`);\n\n    const spectrogramCallback: SpectrogramCallback =\n        async (x: tf.Tensor, timeData?: tf.Tensor) => {\n      const normalizedX = normalize(x);\n      let y: tf.Tensor;\n      let embedding: tf.Tensor;\n      if (config.includeEmbedding) {\n        await this.ensureModelWithEmbeddingOutputCreated();\n        [y, embedding] =\n            this.modelWithEmbeddingOutput.predict(normalizedX) as tf.Tensor[];\n      } else {\n        y = this.model.predict(normalizedX) as tf.Tensor;\n      }\n\n      const scores = await y.data() as Float32Array;\n      const maxIndexTensor = y.argMax(-1);\n      const maxIndex = (await maxIndexTensor.data())[0];\n      const maxScore = Math.max(...scores);\n      tf.dispose([y, maxIndexTensor, normalizedX]);\n\n      if (maxScore < probabilityThreshold) {\n        return false;\n      } else {\n        let spectrogram: SpectrogramData = undefined;\n        if (config.includeSpectrogram) {\n          spectrogram = {\n            data: await x.data() as Float32Array,\n            frameSize: this.nonBatchInputShape[1],\n          };\n        }\n\n        let wordDetected = true;\n        if (!invokeCallbackOnNoiseAndUnknown) {\n          // Skip background noise and unknown tokens.\n          if (this.words[maxIndex] === BACKGROUND_NOISE_TAG ||\n              this.words[maxIndex] === UNKNOWN_TAG) {\n            wordDetected = false;\n          }\n        }\n        if (wordDetected) {\n          callback({scores, spectrogram, embedding});\n        }\n        // Trigger suppression only if the word is neither unknown or\n        // background noise.\n        return wordDetected;\n      }\n    };\n\n    const suppressionTimeMillis = config.suppressionTimeMillis == null ?\n        this.DEFAULT_SUPPRESSION_TIME_MILLIS :\n        config.suppressionTimeMillis;\n    this.audioDataExtractor = new BrowserFftFeatureExtractor({\n      sampleRateHz: this.parameters.sampleRateHz,\n      numFramesPerSpectrogram: this.nonBatchInputShape[0],\n      columnTruncateLength: this.nonBatchInputShape[1],\n      suppressionTimeMillis,\n      spectrogramCallback,\n      overlapFactor\n    });\n\n    await this.audioDataExtractor.start(config.audioTrackConstraints);\n\n    this.streaming = true;\n  }\n\n  /**\n   * Load the underlying tf.LayersModel instance and associated metadata.\n   *\n   * If the model and the metadata are already loaded, do nothing.\n   */\n  async ensureModelLoaded() {\n    if (this.model != null) {\n      return;\n    }\n\n    await this.ensureMetadataLoaded();\n\n    let model: tf.LayersModel;\n    if (typeof this.modelArtifactsOrURL === 'string') {\n      model = await tf.loadLayersModel(this.modelArtifactsOrURL);\n    } else {\n      // this.modelArtifactsOrURL is an instance of `tf.io.ModelArtifacts`.\n      model = await tf.loadLayersModel(tf.io.fromMemory(\n          this.modelArtifactsOrURL.modelTopology,\n          this.modelArtifactsOrURL.weightSpecs,\n          this.modelArtifactsOrURL.weightData));\n    }\n\n    // Check the validity of the model's input shape.\n    if (model.inputs.length !== 1) {\n      throw new Error(\n          `Expected model to have 1 input, but got a model with ` +\n          `${model.inputs.length} inputs`);\n    }\n    if (model.inputs[0].shape.length !== 4) {\n      throw new Error(\n          `Expected model to have an input shape of rank 4, ` +\n          `but got an input shape of rank ${model.inputs[0].shape.length}`);\n    }\n    if (model.inputs[0].shape[3] !== 1) {\n      throw new Error(\n          `Expected model to have an input shape with 1 as the last ` +\n          `dimension, but got input shape` +\n          `${JSON.stringify(model.inputs[0].shape[3])}}`);\n    }\n    // Check the consistency between the word labels and the model's output\n    // shape.\n    const outputShape = model.outputShape as tf.Shape;\n    if (outputShape.length !== 2) {\n      throw new Error(\n          `Expected loaded model to have an output shape of rank 2,` +\n          `but received shape ${JSON.stringify(outputShape)}`);\n    }\n    if (outputShape[1] !== this.words.length) {\n      throw new Error(\n          `Mismatch between the last dimension of model's output shape ` +\n          `(${outputShape[1]}) and number of words ` +\n          `(${this.words.length}).`);\n    }\n\n    this.model = model;\n    this.freezeModel();\n\n    this.nonBatchInputShape =\n        model.inputs[0].shape.slice(1) as [number, number, number];\n    this.elementsPerExample = 1;\n    model.inputs[0].shape.slice(1).forEach(\n        dimSize => this.elementsPerExample *= dimSize);\n    this.warmUpModel();\n    const frameDurationMillis =\n        this.parameters.fftSize / this.parameters.sampleRateHz * 1e3;\n    const numFrames = model.inputs[0].shape[1];\n    this.parameters.spectrogramDurationMillis = numFrames * frameDurationMillis;\n  }\n\n  /**\n   * Construct a two-output model that includes the following outputs:\n   *\n   * 1. The same softmax probability output as the original model's output\n   * 2. The embedding, i.e., activation from the second-last dense layer of\n   *    the original model.\n   */\n  protected async ensureModelWithEmbeddingOutputCreated() {\n    if (this.modelWithEmbeddingOutput != null) {\n      return;\n    }\n    await this.ensureModelLoaded();\n\n    // Find the second last dense layer of the original model.\n    let secondLastDenseLayer: tf.layers.Layer;\n    for (let i = this.model.layers.length - 2; i >= 0; --i) {\n      if (this.model.layers[i].getClassName() === 'Dense') {\n        secondLastDenseLayer = this.model.layers[i];\n        break;\n      }\n    }\n    if (secondLastDenseLayer == null) {\n      throw new Error(\n          'Failed to find second last dense layer in the original model.');\n    }\n    this.modelWithEmbeddingOutput = tf.model({\n      inputs: this.model.inputs,\n      outputs: [\n        this.model.outputs[0], secondLastDenseLayer.output as tf.SymbolicTensor\n      ]\n    });\n  }\n\n  private warmUpModel() {\n    tf.tidy(() => {\n      const x = tf.zeros([1].concat(this.nonBatchInputShape));\n      for (let i = 0; i < 3; ++i) {\n        this.model.predict(x);\n      }\n    });\n  }\n\n  private async ensureMetadataLoaded() {\n    if (this.words != null) {\n      return;\n    }\n\n    const metadataJSON = typeof this.metadataOrURL === 'string' ?\n        await loadMetadataJson(this.metadataOrURL) :\n        this.metadataOrURL;\n\n    if (metadataJSON.wordLabels == null) {\n      // In some legacy formats, the field 'words', instead of 'wordLabels',\n      // was populated. This branch ensures backward compatibility with those\n      // formats.\n      // tslint:disable-next-line:no-any\n      const legacyWords = (metadataJSON as any)['words'] as string[];\n      if (legacyWords == null) {\n        throw new Error(\n            'Cannot find field \"words\" or \"wordLabels\" in metadata JSON file');\n      }\n      this.words = legacyWords;\n    } else {\n      this.words = metadataJSON.wordLabels;\n    }\n  }\n\n  /**\n   * Stop streaming recognition.\n   *\n   * @throws Error if there is not ongoing streaming recognition.\n   */\n  async stopListening(): Promise<void> {\n    if (!this.streaming) {\n      throw new Error('Cannot stop streaming when streaming is not ongoing.');\n    }\n    await this.audioDataExtractor.stop();\n    this.streaming = false;\n  }\n\n  /**\n   * Check if streaming recognition is ongoing.\n   */\n  isListening(): boolean {\n    return this.streaming;\n  }\n\n  /**\n   * Get the array of word labels.\n   *\n   * @throws Error If this model is called before the model is loaded.\n   */\n  wordLabels(): string[] {\n    return this.words;\n  }\n\n  /**\n   * Get the parameters of this instance of BrowserFftSpeechCommandRecognizer.\n   *\n   * @returns Parameters of this instance.\n   */\n  params(): RecognizerParams {\n    return this.parameters;\n  }\n\n  /**\n   * Get the input shape of the underlying tf.LayersModel.\n   *\n   * @returns The input shape.\n   */\n  modelInputShape(): tf.Shape {\n    if (this.model == null) {\n      throw new Error(\n          'Model has not been loaded yet. Load model by calling ' +\n          'ensureModelLoaded(), recognize(), or listen().');\n    }\n    return this.model.inputs[0].shape;\n  }\n\n  /**\n   * Run offline (non-streaming) recognition on a spectrogram.\n   *\n   * @param input Spectrogram. Either a `tf.Tensor` of a `Float32Array`.\n   *   - If a `tf.Tensor`, must be rank-4 and match the model's expected\n   *     input shape in 2nd dimension (# of spectrogram columns), the 3rd\n   *     dimension (# of frequency-domain points per column), and the 4th\n   *     dimension (always 1). The 1st dimension can be 1, for single-example\n   *     recogntion, or any value >1, for batched recognition.\n   *   - If a `Float32Array`, must have a length divisible by the number\n   *     of elements per spectrogram, i.e.,\n   *     (# of spectrogram columns) * (# of frequency-domain points per column).\n   * @param config Optional configuration object.\n   * @returns Result of the recognition, with the following field:\n   *   scores:\n   *   - A `Float32Array` if there is only one input exapmle.\n   *   - An `Array` of `Float32Array`, if there are multiple input examples.\n   */\n  async recognize(input?: tf.Tensor|Float32Array, config?: RecognizeConfig):\n      Promise<SpeechCommandRecognizerResult> {\n    if (config == null) {\n      config = {};\n    }\n\n    await this.ensureModelLoaded();\n\n    if (input == null) {\n      // If `input` is not provided, draw audio data from WebAudio and us it\n      // for recognition.\n      const spectrogramData = await this.recognizeOnline();\n      input = spectrogramData.data;\n    }\n\n    let numExamples: number;\n    let inputTensor: tf.Tensor;\n    let outTensor: tf.Tensor;\n    if (input instanceof tf.Tensor) {\n      // Check input shape.\n      this.checkInputTensorShape(input);\n      inputTensor = input;\n      numExamples = input.shape[0];\n    } else {\n      if (input.length % this.elementsPerExample) {\n        throw new Error(\n            `The length of the input Float32Array ${input.length} ` +\n            `is not divisible by the number of tensor elements per ` +\n            `per example expected by the model ${this.elementsPerExample}.`);\n      }\n\n      numExamples = input.length / this.elementsPerExample;\n      inputTensor = tf.tensor4d(input, [\n        numExamples\n      ].concat(this.nonBatchInputShape) as [number, number, number, number]);\n    }\n\n    const output: SpeechCommandRecognizerResult = {scores: null};\n    if (config.includeEmbedding) {\n      // Optional inclusion of embedding (internal activation).\n      await this.ensureModelWithEmbeddingOutputCreated();\n      const outAndEmbedding =\n          this.modelWithEmbeddingOutput.predict(inputTensor) as tf.Tensor[];\n      outTensor = outAndEmbedding[0];\n      output.embedding = outAndEmbedding[1];\n    } else {\n      outTensor = this.model.predict(inputTensor) as tf.Tensor;\n    }\n\n    if (numExamples === 1) {\n      output.scores = await outTensor.data() as Float32Array;\n    } else {\n      const unstacked = tf.unstack(outTensor);\n      const scorePromises = unstacked.map(item => item.data());\n      output.scores = await Promise.all(scorePromises) as Float32Array[];\n      tf.dispose(unstacked);\n    }\n\n    if (config.includeSpectrogram) {\n      output.spectrogram = {\n        data: (input instanceof tf.Tensor ? await input.data() : input) as\n            Float32Array,\n        frameSize: this.nonBatchInputShape[1],\n      };\n    }\n\n    tf.dispose(outTensor);\n    return output;\n  }\n\n  private async recognizeOnline(): Promise<SpectrogramData> {\n    return new Promise<SpectrogramData>((resolve, reject) => {\n      const spectrogramCallback: SpectrogramCallback = async (x: tf.Tensor) => {\n        const normalizedX = normalize(x);\n        await this.audioDataExtractor.stop();\n        resolve({\n          data: await normalizedX.data() as Float32Array,\n          frameSize: this.nonBatchInputShape[1],\n        });\n        normalizedX.dispose();\n        return false;\n      };\n      this.audioDataExtractor = new BrowserFftFeatureExtractor({\n        sampleRateHz: this.parameters.sampleRateHz,\n        numFramesPerSpectrogram: this.nonBatchInputShape[0],\n        columnTruncateLength: this.nonBatchInputShape[1],\n        suppressionTimeMillis: 0,\n        spectrogramCallback,\n        overlapFactor: 0\n      });\n      this.audioDataExtractor.start();\n    });\n  }\n\n  createTransfer(name: string): TransferSpeechCommandRecognizer {\n    if (this.model == null) {\n      throw new Error(\n          'Model has not been loaded yet. Load model by calling ' +\n          'ensureModelLoaded(), recognizer(), or listen().');\n    }\n    tf.util.assert(\n        name != null && typeof name === 'string' && name.length > 1,\n        () => `Expected the name for a transfer-learning recognized to be a ` +\n            `non-empty string, but got ${JSON.stringify(name)}`);\n    tf.util.assert(\n        this.transferRecognizers[name] == null,\n        () => `There is already a transfer-learning model named '${name}'`);\n    const transfer = new TransferBrowserFftSpeechCommandRecognizer(\n        name, this.parameters, this.model);\n    this.transferRecognizers[name] = transfer;\n    return transfer;\n  }\n\n  protected freezeModel(): void {\n    for (const layer of this.model.layers) {\n      layer.trainable = false;\n    }\n  }\n\n  private checkInputTensorShape(input: tf.Tensor) {\n    const expectedRank = this.model.inputs[0].shape.length;\n    if (input.shape.length !== expectedRank) {\n      throw new Error(\n          `Expected input Tensor to have rank ${expectedRank}, ` +\n          `but got rank ${input.shape.length} that differs `);\n    }\n    const nonBatchedShape = input.shape.slice(1);\n    const expectedNonBatchShape = this.model.inputs[0].shape.slice(1);\n    if (!tf.util.arraysEqual(nonBatchedShape, expectedNonBatchShape)) {\n      throw new Error(\n          `Expected input to have shape [null,${expectedNonBatchShape}], ` +\n          `but got shape [null,${nonBatchedShape}]`);\n    }\n  }\n}\n\n/**\n * A subclass of BrowserFftSpeechCommandRecognizer: Transfer-learned model.\n */\nclass TransferBrowserFftSpeechCommandRecognizer extends\n    BrowserFftSpeechCommandRecognizer implements\n        TransferSpeechCommandRecognizer {\n  private dataset: Dataset;\n  private transferHead: tf.Sequential;\n\n  /**\n   * Constructor of TransferBrowserFftSpeechCommandRecognizer.\n   *\n   * @param name Name of the transfer-learned recognizer. Must be a non-empty\n   *   string.\n   * @param parameters Parameters from the base recognizer.\n   * @param baseModel Model from the base recognizer.\n   */\n  constructor(\n      readonly name: string, readonly parameters: RecognizerParams,\n      readonly baseModel: tf.LayersModel) {\n    super();\n    tf.util.assert(\n        name != null && typeof name === 'string' && name.length > 0,\n        () => `The name of a transfer model must be a non-empty string, ` +\n            `but got ${JSON.stringify(name)}`);\n    this.nonBatchInputShape =\n        this.baseModel.inputs[0].shape.slice(1) as [number, number, number];\n    this.words = null;\n    this.dataset = new Dataset();\n  }\n\n  /**\n   * Collect an example for transfer learning via WebAudio.\n   *\n   * @param {string} word Name of the word. Must not overlap with any of the\n   *   words the base model is trained to recognize.\n   * @param {ExampleCollectionOptions}\n   * @returns {SpectrogramData} The spectrogram of the acquired the example.\n   * @throws Error, if word belongs to the set of words the base model is\n   *   trained to recognize.\n   */\n  async collectExample(word: string, options?: ExampleCollectionOptions):\n      Promise<SpectrogramData> {\n    tf.util.assert(\n        !this.streaming,\n        () => 'Cannot start collection of transfer-learning example because ' +\n            'a streaming recognition or transfer-learning example collection ' +\n            'is ongoing');\n    tf.util.assert(\n        word != null && typeof word === 'string' && word.length > 0,\n        () => `Must provide a non-empty string when collecting transfer-` +\n            `learning example`);\n\n    if (options == null) {\n      options = {};\n    }\n    if (options.durationMultiplier != null && options.durationSec != null) {\n      throw new Error(\n          `durationMultiplier and durationSec are mutually exclusive, ` +\n          `but are both specified.`);\n    }\n\n    let numFramesPerSpectrogram: number;\n    if (options.durationSec != null) {\n      tf.util.assert(\n          options.durationSec > 0,\n          () =>\n              `Expected durationSec to be > 0, but got ${options.durationSec}`);\n      const frameDurationSec =\n          this.parameters.fftSize / this.parameters.sampleRateHz;\n      numFramesPerSpectrogram =\n          Math.ceil(options.durationSec / frameDurationSec);\n    } else if (options.durationMultiplier != null) {\n      tf.util.assert(\n          options.durationMultiplier >= 1,\n          () => `Expected duration multiplier to be >= 1, ` +\n              `but got ${options.durationMultiplier}`);\n      numFramesPerSpectrogram =\n          Math.round(this.nonBatchInputShape[0] * options.durationMultiplier);\n    } else {\n      numFramesPerSpectrogram = this.nonBatchInputShape[0];\n    }\n\n    if (options.snippetDurationSec != null) {\n      tf.util.assert(\n          options.snippetDurationSec > 0,\n          () => `snippetDurationSec is expected to be > 0, but got ` +\n              `${options.snippetDurationSec}`);\n      tf.util.assert(\n          options.onSnippet != null,\n          () => `onSnippet must be provided if snippetDurationSec ` +\n              `is provided.`);\n    }\n    if (options.onSnippet != null) {\n      tf.util.assert(\n          options.snippetDurationSec != null,\n          () => `snippetDurationSec must be provided if onSnippet ` +\n              `is provided.`);\n    }\n    const frameDurationSec =\n        this.parameters.fftSize / this.parameters.sampleRateHz;\n    const totalDurationSec = frameDurationSec * numFramesPerSpectrogram;\n\n    this.streaming = true;\n    return new Promise<SpectrogramData>(resolve => {\n      const stepFactor = options.snippetDurationSec == null ?\n          1 :\n          options.snippetDurationSec / totalDurationSec;\n      const overlapFactor = 1 - stepFactor;\n      const callbackCountTarget = Math.round(1 / stepFactor);\n      let callbackCount = 0;\n      let lastIndex = -1;\n      const spectrogramSnippets: Float32Array[] = [];\n\n      const spectrogramCallback: SpectrogramCallback =\n          async (freqData: tf.Tensor, timeData?: tf.Tensor) => {\n        // TODO(cais): can we consolidate the logic in the two branches?\n        if (options.onSnippet == null) {\n          const normalizedX = normalize(freqData);\n          this.dataset.addExample({\n            label: word,\n            spectrogram: {\n              data: await normalizedX.data() as Float32Array,\n              frameSize: this.nonBatchInputShape[1],\n            },\n            rawAudio: options.includeRawAudio ? {\n              data: await timeData.data() as Float32Array,\n              sampleRateHz: this.audioDataExtractor.sampleRateHz\n            } :\n                                                undefined\n          });\n          normalizedX.dispose();\n          await this.audioDataExtractor.stop();\n          this.streaming = false;\n          this.collateTransferWords();\n          resolve({\n            data: await freqData.data() as Float32Array,\n            frameSize: this.nonBatchInputShape[1],\n          });\n        } else {\n          const data = await freqData.data() as Float32Array;\n          if (lastIndex === -1) {\n            lastIndex = data.length;\n          }\n          let i = lastIndex - 1;\n          while (data[i] !== 0 && i >= 0) {\n            i--;\n          }\n          const increment = lastIndex - i - 1;\n          lastIndex = i + 1;\n          const snippetData = data.slice(data.length - increment, data.length);\n          spectrogramSnippets.push(snippetData);\n\n          if (options.onSnippet != null) {\n            options.onSnippet(\n                {data: snippetData, frameSize: this.nonBatchInputShape[1]});\n          }\n\n          if (callbackCount++ === callbackCountTarget) {\n            await this.audioDataExtractor.stop();\n            this.streaming = false;\n            this.collateTransferWords();\n\n            const normalized = normalizeFloat32Array(\n                concatenateFloat32Arrays(spectrogramSnippets));\n            const finalSpectrogram: SpectrogramData = {\n              data: normalized,\n              frameSize: this.nonBatchInputShape[1]\n            };\n            this.dataset.addExample({\n              label: word,\n              spectrogram: finalSpectrogram,\n              rawAudio: options.includeRawAudio ? {\n                data: await timeData.data() as Float32Array,\n                sampleRateHz: this.audioDataExtractor.sampleRateHz\n              } :\n                                                  undefined\n            });\n            // TODO(cais): Fix 1-tensor memory leak.\n            resolve(finalSpectrogram);\n          }\n        }\n        return false;\n      };\n      this.audioDataExtractor = new BrowserFftFeatureExtractor({\n        sampleRateHz: this.parameters.sampleRateHz,\n        numFramesPerSpectrogram,\n        columnTruncateLength: this.nonBatchInputShape[1],\n        suppressionTimeMillis: 0,\n        spectrogramCallback,\n        overlapFactor,\n        includeRawAudio: options.includeRawAudio\n      });\n      this.audioDataExtractor.start(options.audioTrackConstraints);\n    });\n  }\n\n  /**\n   * Clear all transfer learning examples collected so far.\n   */\n  clearExamples(): void {\n    tf.util.assert(\n        this.words != null && this.words.length > 0 && !this.dataset.empty(),\n        () =>\n            `No transfer learning examples exist for model name ${this.name}`);\n    this.dataset.clear();\n    this.words = null;\n  }\n\n  /**\n   * Get counts of the word examples that have been collected for a\n   * transfer-learning model.\n   *\n   * @returns {{[word: string]: number}} A map from word name to number of\n   *   examples collected for that word so far.\n   */\n  countExamples(): {[word: string]: number} {\n    if (this.dataset.empty()) {\n      throw new Error(\n          `No examples have been collected for transfer-learning model ` +\n          `named '${this.name}' yet.`);\n    }\n    return this.dataset.getExampleCounts();\n  }\n\n  /**\n   * Get examples currently held by the transfer-learning recognizer.\n   *\n   * @param label Label requested.\n   * @returns An array of `Example`s, along with their UIDs.\n   */\n  getExamples(label: string): Array<{uid: string, example: Example}> {\n    return this.dataset.getExamples(label);\n  }\n\n  /** Set the key frame index of a given example. */\n  setExampleKeyFrameIndex(uid: string, keyFrameIndex: number): void {\n    this.dataset.setExampleKeyFrameIndex(uid, keyFrameIndex);\n  }\n\n  /**\n   * Remove an example from the current dataset.\n   *\n   * @param uid The UID of the example to remove.\n   */\n  removeExample(uid: string): void {\n    this.dataset.removeExample(uid);\n    this.collateTransferWords();\n  }\n\n  /**\n   * Check whether the underlying dataset is empty.\n   *\n   * @returns A boolean indicating whether the underlying dataset is empty.\n   */\n  isDatasetEmpty(): boolean {\n    return this.dataset.empty();\n  }\n\n  /**\n   * Load an array of serialized examples.\n   *\n   * @param serialized The examples in their serialized format.\n   * @param clearExisting Whether to clear the existing examples while\n   *   performing the loading (default: false).\n   */\n  loadExamples(serialized: ArrayBuffer, clearExisting = false): void {\n    const incomingDataset = new Dataset(serialized);\n    if (clearExisting) {\n      this.clearExamples();\n    }\n\n    const incomingVocab = incomingDataset.getVocabulary();\n    for (const label of incomingVocab) {\n      const examples = incomingDataset.getExamples(label);\n      for (const example of examples) {\n        this.dataset.addExample(example.example);\n      }\n    }\n\n    this.collateTransferWords();\n  }\n\n  /**\n   * Serialize the existing examples.\n   *\n   * @param wordLabels Optional word label(s) to serialize. If specified, only\n   *   the examples with labels matching the argument will be serialized. If\n   *   any specified word label does not exist in the vocabulary of this\n   *   transfer recognizer, an Error will be thrown.\n   * @returns An `ArrayBuffer` object amenable to transmission and storage.\n   */\n  serializeExamples(wordLabels?: string|string[]): ArrayBuffer {\n    return this.dataset.serialize(wordLabels);\n  }\n\n  /**\n   * Collect the vocabulary of this transfer-learned recognizer.\n   *\n   * The words are put in an alphabetically sorted order.\n   */\n  private collateTransferWords() {\n    this.words = this.dataset.getVocabulary();\n  }\n\n  /**\n   * Collect the transfer-learning data as `tf.Tensor`s.\n   *\n   * Used for training and evaluation when the amount of data is relatively\n   * small.\n   *\n   * @param windowHopRatio Ratio betwen hop length in number of frames and the\n   *   number of frames in a long spectrogram. Used during extraction\n   *   of multiple windows from the long spectrogram.\n   * @returns xs: The feature tensors (xs), a 4D tf.Tensor.\n   *          ys: The target tensors (ys), one-hot encoding, a 2D tf.Tensor.\n   */\n  private collectTransferDataAsTensors(\n      windowHopRatio?: number,\n      augmentationOptions?: AudioDataAugmentationOptions):\n      {xs: tf.Tensor, ys: tf.Tensor} {\n    const numFrames = this.nonBatchInputShape[0];\n    windowHopRatio = windowHopRatio || DEFAULT_WINDOW_HOP_RATIO;\n    const hopFrames = Math.round(windowHopRatio * numFrames);\n    const out = this.dataset.getData(\n                    null, {numFrames, hopFrames, ...augmentationOptions}) as\n        {xs: tf.Tensor4D, ys?: tf.Tensor2D};\n    return {xs: out.xs, ys: out.ys as tf.Tensor};\n  }\n\n  /**\n   * Same as `collectTransferDataAsTensors`, but returns `tf.data.Dataset`s.\n   *\n   * Used for training and evaluation when the amount of data is large.\n   *\n   * @param windowHopRatio Ratio betwen hop length in number of frames and the\n   *   number of frames in a long spectrogram. Used during extraction\n   *   of multiple windows from the long spectrogram.\n   * @param validationSplit The validation split to be used for splitting\n   *   the raw data between the `tf.data.Dataset` objects for training and\n   *   validation.\n   * @param batchSize Batch size used for the `tf.data.Dataset.batch()` call\n   *   during the creation of the dataset objects.\n   * @return Two `tf.data.Dataset` objects, one for training and one for\n   *   validation. Each of the objects may be directly fed into\n   *   `this.model.fitDataset`.\n   */\n  private collectTransferDataAsTfDataset(\n      windowHopRatio?: number, validationSplit = 0.15, batchSize = 32,\n      augmentationOptions?: AudioDataAugmentationOptions):\n      [tf.data.Dataset<{}>, tf.data.Dataset<{}>] {\n    const numFrames = this.nonBatchInputShape[0];\n    windowHopRatio = windowHopRatio || DEFAULT_WINDOW_HOP_RATIO;\n    const hopFrames = Math.round(windowHopRatio * numFrames);\n    return this.dataset.getData(null, {\n      numFrames,\n      hopFrames,\n      getDataset: true,\n      datasetBatchSize: batchSize,\n      datasetValidationSplit: validationSplit,\n      ...augmentationOptions\n    }) as [tf.data.Dataset<{}>, tf.data.Dataset<{}>];\n    // TODO(cais): See if we can tighten the typing.\n  }\n\n  /**\n   * Train the transfer-learning model.\n   *\n   * The last dense layer of the base model is replaced with new softmax dense\n   * layer.\n   *\n   * It is assume that at least one category of data has been collected (using\n   * multiple calls to the `collectTransferExample` method).\n   *\n   * @param config {TransferLearnConfig} Optional configurations fot the\n   *   training of the transfer-learning model.\n   * @returns {tf.History} A history object with the loss and accuracy values\n   *   from the training of the transfer-learning model.\n   * @throws Error, if `modelName` is invalid or if not sufficient training\n   *   examples have been collected yet.\n   */\n  async train(config?: TransferLearnConfig):\n      Promise<tf.History|[tf.History, tf.History]> {\n    tf.util.assert(\n        this.words != null && this.words.length > 0,\n        () =>\n            `Cannot train transfer-learning model '${this.name}' because no ` +\n            `transfer learning example has been collected.`);\n    tf.util.assert(\n        this.words.length > 1,\n        () => `Cannot train transfer-learning model '${\n                  this.name}' because only ` +\n            `1 word label ('${JSON.stringify(this.words)}') ` +\n            `has been collected for transfer learning. Requires at least 2.`);\n    if (config.fineTuningEpochs != null) {\n      tf.util.assert(\n          config.fineTuningEpochs >= 0 &&\n              Number.isInteger(config.fineTuningEpochs),\n          () => `If specified, fineTuningEpochs must be a non-negative ` +\n              `integer, but received ${config.fineTuningEpochs}`);\n    }\n\n    if (config == null) {\n      config = {};\n    }\n\n    if (this.model == null) {\n      this.createTransferModelFromBaseModel();\n    }\n\n    // This layer needs to be frozen for the initial phase of the\n    // transfer learning. During subsequent fine-tuning (if any), it will\n    // be unfrozen.\n    this.secondLastBaseDenseLayer.trainable = false;\n\n    // Compile model for training.\n    this.model.compile({\n      loss: 'categoricalCrossentropy',\n      optimizer: config.optimizer || 'sgd',\n      metrics: ['acc']\n    });\n\n    // Use `tf.data.Dataset` objects for training of the total duration of\n    // the recordings exceeds 60 seconds. Otherwise, use `tf.Tensor` objects.\n    const datasetDurationMillisThreshold =\n        config.fitDatasetDurationMillisThreshold == null ?\n        60e3 :\n        config.fitDatasetDurationMillisThreshold;\n    if (this.dataset.durationMillis() > datasetDurationMillisThreshold) {\n      console.log(\n          `Detected large dataset: total duration = ` +\n          `${this.dataset.durationMillis()} ms > ` +\n          `${datasetDurationMillisThreshold} ms. ` +\n          `Training transfer model using fitDataset() instead of fit()`);\n      return this.trainOnDataset(config);\n    } else {\n      return this.trainOnTensors(config);\n    }\n  }\n\n  /** Helper function for training on tf.data.Dataset objects. */\n  private async trainOnDataset(config?: TransferLearnConfig):\n      Promise<tf.History|[tf.History, tf.History]> {\n    tf.util.assert(config.epochs > 0, () => `Invalid config.epochs`);\n    // Train transfer-learning model using fitDataset\n\n    const batchSize = config.batchSize == null ? 32 : config.batchSize;\n    const windowHopRatio = config.windowHopRatio || DEFAULT_WINDOW_HOP_RATIO;\n    const [trainDataset, valDataset] = this.collectTransferDataAsTfDataset(\n        windowHopRatio, config.validationSplit, batchSize,\n        {augmentByMixingNoiseRatio: config.augmentByMixingNoiseRatio});\n    const t0 = tf.util.now();\n    const history = await this.model.fitDataset(trainDataset, {\n      epochs: config.epochs,\n      validationData: config.validationSplit > 0 ? valDataset : null,\n      callbacks: config.callback == null ? null : [config.callback]\n    });\n    console.log(`fitDataset() took ${(tf.util.now() - t0).toFixed(2)} ms`);\n\n    if (config.fineTuningEpochs != null && config.fineTuningEpochs > 0) {\n      // Perform fine-tuning.\n      const t0 = tf.util.now();\n      const fineTuningHistory = await this.fineTuningUsingTfDatasets(\n          config, trainDataset, valDataset);\n      console.log(\n          `fitDataset() (fine-tuning) took ` +\n          `${(tf.util.now() - t0).toFixed(2)} ms`);\n      return [history, fineTuningHistory];\n    } else {\n      return history;\n    }\n  }\n\n  /** Helper function for training on tf.Tensor objects. */\n  private async trainOnTensors(config?: TransferLearnConfig):\n      Promise<tf.History|[tf.History, tf.History]> {\n    // Prepare the data.\n    const windowHopRatio = config.windowHopRatio || DEFAULT_WINDOW_HOP_RATIO;\n    const {xs, ys} = this.collectTransferDataAsTensors(\n        windowHopRatio,\n        {augmentByMixingNoiseRatio: config.augmentByMixingNoiseRatio});\n    console.log(\n        `Training data: xs.shape = ${xs.shape}, ys.shape = ${ys.shape}`);\n\n    let trainXs: tf.Tensor;\n    let trainYs: tf.Tensor;\n    let valData: [tf.Tensor, tf.Tensor];\n    try {\n      // TODO(cais): The balanced split may need to be pushed down to the\n      //   level of the Dataset class to avoid leaks between train and val\n      //   splits.\n      if (config.validationSplit != null) {\n        const splits = balancedTrainValSplit(xs, ys, config.validationSplit);\n        trainXs = splits.trainXs;\n        trainYs = splits.trainYs;\n        valData = [splits.valXs, splits.valYs];\n      } else {\n        trainXs = xs;\n        trainYs = ys;\n      }\n\n      const history = await this.model.fit(trainXs, trainYs, {\n        epochs: config.epochs == null ? 20 : config.epochs,\n        validationData: valData,\n        batchSize: config.batchSize,\n        callbacks: config.callback == null ? null : [config.callback]\n      });\n\n      if (config.fineTuningEpochs != null && config.fineTuningEpochs > 0) {\n        // Fine tuning: unfreeze the second-last dense layer of the base\n        // model.\n        const fineTuningHistory = await this.fineTuningUsingTensors(\n            config, trainXs, trainYs, valData);\n        return [history, fineTuningHistory];\n      } else {\n        return history;\n      }\n    } finally {\n      tf.dispose([xs, ys, trainXs, trainYs, valData]);\n    }\n  }\n\n  private async fineTuningUsingTfDatasets(\n      config: TransferLearnConfig, trainDataset: tf.data.Dataset<{}>,\n      valDataset: tf.data.Dataset<{}>): Promise<tf.History> {\n    const originalTrainableValue = this.secondLastBaseDenseLayer.trainable;\n    this.secondLastBaseDenseLayer.trainable = true;\n\n    // Recompile model after unfreezing layer.\n    const fineTuningOptimizer: string|tf.Optimizer =\n        config.fineTuningOptimizer == null ? 'sgd' : config.fineTuningOptimizer;\n    this.model.compile({\n      loss: 'categoricalCrossentropy',\n      optimizer: fineTuningOptimizer,\n      metrics: ['acc']\n    });\n\n    const fineTuningHistory = await this.model.fitDataset(trainDataset, {\n      epochs: config.fineTuningEpochs,\n      validationData: valDataset,\n      callbacks: config.callback == null ? null : [config.callback]\n    });\n    // Set the trainable attribute of the fine-tuning layer to its\n    // previous value.\n    this.secondLastBaseDenseLayer.trainable = originalTrainableValue;\n    return fineTuningHistory;\n  }\n\n  private async fineTuningUsingTensors(\n      config: TransferLearnConfig, trainXs: tf.Tensor, trainYs: tf.Tensor,\n      valData: [tf.Tensor, tf.Tensor]): Promise<tf.History> {\n    const originalTrainableValue = this.secondLastBaseDenseLayer.trainable;\n    this.secondLastBaseDenseLayer.trainable = true;\n\n    // Recompile model after unfreezing layer.\n    const fineTuningOptimizer: string|tf.Optimizer =\n        config.fineTuningOptimizer == null ? 'sgd' : config.fineTuningOptimizer;\n    this.model.compile({\n      loss: 'categoricalCrossentropy',\n      optimizer: fineTuningOptimizer,\n      metrics: ['acc']\n    });\n\n    const fineTuningHistory = await this.model.fit(trainXs, trainYs, {\n      epochs: config.fineTuningEpochs,\n      validationData: valData,\n      batchSize: config.batchSize,\n      callbacks: config.fineTuningCallback == null ? null :\n                                                     [config.fineTuningCallback]\n    });\n    // Set the trainable attribute of the fine-tuning layer to its\n    // previous value.\n    this.secondLastBaseDenseLayer.trainable = originalTrainableValue;\n    return fineTuningHistory;\n  }\n\n  /**\n   * Perform evaluation of the model using the examples that the model\n   * has loaded.\n   *\n   * @param config Configuration object for the evaluation.\n   * @returns A Promise of the result of evaluation.\n   */\n  async evaluate(config: EvaluateConfig): Promise<EvaluateResult> {\n    tf.util.assert(\n        config.wordProbThresholds != null &&\n            config.wordProbThresholds.length > 0,\n        () => `Received null or empty wordProbThresholds`);\n\n    // TODO(cais): Maybe relax this requirement.\n    const NOISE_CLASS_INDEX = 0;\n    tf.util.assert(\n        this.words[NOISE_CLASS_INDEX] === BACKGROUND_NOISE_TAG,\n        () => `Cannot perform evaluation when the first tag is not ` +\n            `${BACKGROUND_NOISE_TAG}`);\n\n    return tf.tidy(() => {\n      const rocCurve: ROCCurve = [];\n      let auc = 0;\n      const {xs, ys} = this.collectTransferDataAsTensors(config.windowHopRatio);\n      const indices = ys.argMax(-1).dataSync();\n      const probs = this.model.predict(xs) as tf.Tensor;\n\n      // To calcaulte ROC, we collapse all word probabilites into a single\n      // positive class, while _background_noise_ is treated as the\n      // negative class.\n      const maxWordProbs =\n          probs.slice([0, 1], [probs.shape[0], probs.shape[1] - 1]).max(-1);\n      const total = probs.shape[0];\n\n      // Calculate ROC curve.\n      for (let i = 0; i < config.wordProbThresholds.length; ++i) {\n        const probThreshold = config.wordProbThresholds[i];\n        const isWord =\n            maxWordProbs.greater(tf.scalar(probThreshold)).dataSync();\n\n        let negatives = 0;\n        let positives = 0;\n        let falsePositives = 0;\n        let truePositives = 0;\n        for (let i = 0; i < total; ++i) {\n          if (indices[i] === NOISE_CLASS_INDEX) {\n            negatives++;\n            if (isWord[i]) {\n              falsePositives++;\n            }\n          } else {\n            positives++;\n            if (isWord[i]) {\n              truePositives++;\n            }\n          }\n        }\n\n        // TODO(cais): Calculate per-hour false-positive rate.\n        const fpr = falsePositives / negatives;\n        const tpr = truePositives / positives;\n\n        rocCurve.push({probThreshold, fpr, tpr});\n        console.log(\n            `ROC thresh=${probThreshold}: ` +\n            `fpr=${fpr.toFixed(4)}, tpr=${tpr.toFixed(4)}`);\n\n        if (i > 0) {\n          // Accumulate to AUC.\n          auc += Math.abs((rocCurve[i - 1].fpr - rocCurve[i].fpr)) *\n              (rocCurve[i - 1].tpr + rocCurve[i].tpr) / 2;\n        }\n      }\n      return {rocCurve, auc};\n    });\n  }\n\n  /**\n   * Create an instance of tf.LayersModel for transfer learning.\n   *\n   * The top dense layer of the base model is replaced with a new softmax\n   * dense layer.\n   */\n  private createTransferModelFromBaseModel(): void {\n    tf.util.assert(\n        this.words != null,\n        () =>\n            `No word example is available for tranfer-learning model of name ` +\n            this.name);\n\n    // Find the second last dense layer.\n    const layers = this.baseModel.layers;\n    let layerIndex = layers.length - 2;\n    while (layerIndex >= 0) {\n      if (layers[layerIndex].getClassName().toLowerCase() === 'dense') {\n        break;\n      }\n      layerIndex--;\n    }\n    if (layerIndex < 0) {\n      throw new Error('Cannot find a hidden dense layer in the base model.');\n    }\n    this.secondLastBaseDenseLayer = layers[layerIndex];\n    const truncatedBaseOutput =\n        this.secondLastBaseDenseLayer.output as tf.SymbolicTensor;\n\n    this.transferHead = tf.sequential();\n    this.transferHead.add(tf.layers.dense({\n      units: this.words.length,\n      activation: 'softmax',\n      inputShape: truncatedBaseOutput.shape.slice(1),\n      name: 'NewHeadDense'\n    }));\n    const transferOutput =\n        this.transferHead.apply(truncatedBaseOutput) as tf.SymbolicTensor;\n    this.model =\n        tf.model({inputs: this.baseModel.inputs, outputs: transferOutput});\n  }\n\n  /**\n   * Get the input shape of the underlying tf.LayersModel.\n   *\n   * @returns The input shape.\n   */\n  modelInputShape(): tf.Shape {\n    return this.baseModel.inputs[0].shape;\n  }\n\n  getMetadata(): SpeechCommandRecognizerMetadata {\n    return {\n      tfjsSpeechCommandsVersion: version,\n      modelName: this.name,\n      timeStamp: new Date().toISOString(),\n      wordLabels: this.wordLabels()\n    };\n  }\n\n  async save(handlerOrURL?: string|tf.io.IOHandler): Promise<tf.io.SaveResult> {\n    const isCustomPath = handlerOrURL != null;\n    handlerOrURL = handlerOrURL || getCanonicalSavePath(this.name);\n\n    if (!isCustomPath) {\n      // First, save the words and other metadata.\n      const metadataMapStr =\n          localStorageWrapper.localStorage.getItem(SAVED_MODEL_METADATA_KEY);\n      const metadataMap =\n          metadataMapStr == null ? {} : JSON.parse(metadataMapStr);\n      metadataMap[this.name] = this.getMetadata();\n      localStorageWrapper.localStorage.setItem(\n          SAVED_MODEL_METADATA_KEY, JSON.stringify(metadataMap));\n    }\n    console.log(`Saving model to ${handlerOrURL}`);\n    return this.model.save(handlerOrURL);\n  }\n\n  async load(handlerOrURL?: string|tf.io.IOHandler): Promise<void> {\n    const isCustomPath = handlerOrURL != null;\n    handlerOrURL = handlerOrURL || getCanonicalSavePath(this.name);\n\n    if (!isCustomPath) {\n      // First, load the words and other metadata.\n      const metadataMap = JSON.parse(\n          localStorageWrapper.localStorage.getItem(SAVED_MODEL_METADATA_KEY));\n      if (metadataMap == null || metadataMap[this.name] == null) {\n        throw new Error(\n            `Cannot find metadata for transfer model named ${this.name}\"`);\n      }\n      this.words = metadataMap[this.name].wordLabels;\n      console.log(\n          `Loaded word list for model named ${this.name}: ${this.words}`);\n    }\n    this.model = await tf.loadLayersModel(handlerOrURL);\n    console.log(`Loaded model from ${handlerOrURL}:`);\n    this.model.summary();\n  }\n\n  /**\n   * Overridden method to prevent creating a nested transfer-learning\n   * recognizer.\n   *\n   * @param name\n   */\n  createTransfer(name: string): TransferBrowserFftSpeechCommandRecognizer {\n    throw new Error(\n        'Creating transfer-learned recognizer from a transfer-learned ' +\n        'recognizer is not supported.');\n  }\n}\n\nfunction getCanonicalSavePath(name: string): string {\n  return `${SAVE_PATH_PREFIX}${name}`;\n}\n\n/**\n * List the model that are currently saved locally in the browser.\n *\n * @returns An array of transfer-learned speech-commands models\n *   that are currently saved in the browser locally.\n */\nexport async function listSavedTransferModels(): Promise<string[]> {\n  const models = await tf.io.listModels();\n  const keys = [];\n  for (const key in models) {\n    if (key.startsWith(SAVE_PATH_PREFIX)) {\n      keys.push(key.slice(SAVE_PATH_PREFIX.length));\n    }\n  }\n  return keys;\n}\n\n/**\n * Delete a locally-saved, transfer-learned speech-commands model.\n *\n * @param name The name of the transfer-learned model to be deleted.\n */\nexport async function deleteSavedTransferModel(name: string): Promise<void> {\n  // Delete the words from local storage.\n  let metadataMap = JSON.parse(\n      localStorageWrapper.localStorage.getItem(SAVED_MODEL_METADATA_KEY));\n  if (metadataMap == null) {\n    metadataMap = {};\n  }\n  if (metadataMap[name] != null) {\n    delete metadataMap[name];\n  }\n  localStorageWrapper.localStorage.setItem(\n      SAVED_MODEL_METADATA_KEY, JSON.stringify(metadataMap));\n  await tf.io.removeModel(getCanonicalSavePath(name));\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs';\n\nimport {BrowserFftSpeechCommandRecognizer} from './browser_fft_recognizer';\nimport {playRawAudio} from './browser_fft_utils';\nimport {concatenateFloat32Arrays} from './generic_utils';\nimport {FFT_TYPE, SpeechCommandRecognizer, SpeechCommandRecognizerMetadata} from './types';\n\n/**\n * Create an instance of speech-command recognizer.\n *\n * @param fftType Type of FFT. The currently availble option(s):\n *   - BROWSER_FFT: Obtains audio spectrograms using browser's native Fourier\n *     transform.\n * @param vocabulary The vocabulary of the model to load. Possible options:\n *   - '18w' (default): The 18-word vocaulbary, consisting of:\n *     'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven',\n *     'eight', 'nine', 'up', 'down', 'left', 'right', 'go', 'stop',\n *     'yes', and 'no', in addition to '_background_noise_' and '_unknown_'.\n *   - 'directional4w': The four directional words: 'up', 'down', 'left', and\n *     'right', in addition to '_background_noise_' and '_unknown_'.\n *   Choosing a smaller vocabulary leads to better accuracy on the words of\n *   interest and a slightly smaller model size.\n * @param customModelArtifactsOrURL A custom model URL pointing to a model.json\n *     file, or a set of modelArtifacts in `tf.io.ModelArtifacts` format.\n *   Supported schemes: http://, https://, and node.js-only: file://.\n *   Mutually exclusive with `vocabulary`. If provided, `customMetadatURL`\n *   most also be provided.\n * @param customMetadataOrURL A custom metadata URL pointing to a metadata.json\n *   file. Must be provided together with `customModelURL`, or a metadata\n *   object.\n * @returns An instance of SpeechCommandRecognizer.\n * @throws Error on invalid value of `fftType`.\n */\nexport function create(\n    fftType: FFT_TYPE, vocabulary?: string,\n    customModelArtifactsOrURL?: tf.io.ModelArtifacts|string,\n    customMetadataOrURL?: SpeechCommandRecognizerMetadata|\n    string): SpeechCommandRecognizer {\n  tf.util.assert(\n      customModelArtifactsOrURL == null && customMetadataOrURL == null ||\n          customModelArtifactsOrURL != null && customMetadataOrURL != null,\n      () => `customModelURL and customMetadataURL must be both provided or ` +\n          `both not provided.`);\n  if (customModelArtifactsOrURL != null) {\n    tf.util.assert(\n        vocabulary == null,\n        () => `vocabulary name must be null or undefined when modelURL ` +\n            `is provided.`);\n  }\n\n  if (fftType === 'BROWSER_FFT') {\n    return new BrowserFftSpeechCommandRecognizer(\n        vocabulary, customModelArtifactsOrURL, customMetadataOrURL);\n  } else if (fftType === 'SOFT_FFT') {\n    throw new Error(\n        'SOFT_FFT SpeechCommandRecognizer has not been implemented yet.');\n  } else {\n    throw new Error(`Invalid fftType: '${fftType}'`);\n  }\n}\n\nconst utils = {\n  concatenateFloat32Arrays,\n  playRawAudio\n};\n\nexport {BACKGROUND_NOISE_TAG, Dataset, GetDataConfig as GetSpectrogramsAsTensorsConfig, getMaxIntensityFrameIndex, spectrogram2IntensityCurve, SpectrogramAndTargetsTfDataset} from './dataset';\nexport {AudioDataAugmentationOptions, Example, FFT_TYPE, RawAudioData, RecognizerParams, SpectrogramData, SpeechCommandRecognizer, SpeechCommandRecognizerMetadata, SpeechCommandRecognizerResult, StreamingRecognitionConfig, TransferLearnConfig, TransferSpeechCommandRecognizer} from './types';\nexport {deleteSavedTransferModel, listSavedTransferModels, UNKNOWN_TAG} from './browser_fft_recognizer';\nexport {utils};\nexport {version} from './version';\n"],"names":["promisify","tf.backend","tf.tidy","tf.util","tf.dispose","tf.tensor","tf.gather","tslib_1.__values","tf.tensor3d","tf.data","tf.oneHot","tf.tensor1d","tf.stack","tf.tensor2d","version","tf.loadLayersModel","tf.io","tf.model","tf.zeros","tf.Tensor","tf.tensor4d","tf.unstack","tslib_1.__extends","tslib_1.__read","tf.scalar","tf.sequential","tf.layers"],"mappings":"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"}